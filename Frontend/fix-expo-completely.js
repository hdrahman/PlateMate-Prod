// Comprehensive fix for Expo CLI fetch errors
// Run with: node fix-expo-completely.js

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('üîß Starting comprehensive Expo CLI fetch error fix...');

// 1. Update package.json scripts
console.log('\nüì¶ Updating package.json scripts...');
const packagePath = path.join(__dirname, 'package.json');
let packageJson;

try {
    packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));

    // Update the start script
    if (packageJson.scripts && packageJson.scripts.start) {
        packageJson.scripts.start = 'cross-env EXPO_CLI_NO_DOCTOR=1 EXPO_NO_DOCTOR=1 expo start';
        console.log('‚úÖ Updated "start" script with EXPO_CLI_NO_DOCTOR=1');
    }

    // Add offline script if it doesn't exist
    if (packageJson.scripts && !packageJson.scripts['start-offline']) {
        packageJson.scripts['start-offline'] = 'cross-env EXPO_CLI_NO_DOCTOR=1 EXPO_NO_DOCTOR=1 EXPO_OFFLINE=1 expo start --offline';
        console.log('‚úÖ Added "start-offline" script');
    }

    // Write the updated package.json
    fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2));
} catch (err) {
    console.error('‚ùå Error updating package.json:', err.message);
}

// 2. Update .env file
console.log('\nüìÑ Updating .env file...');
const envPath = path.join(__dirname, '.env');
let envContent = '';

try {
    envContent = fs.existsSync(envPath) ? fs.readFileSync(envPath, 'utf8') : '';

    // Add environment variables if not already present
    const envVars = [
        { key: 'EXPO_CLI_NO_DOCTOR', value: '1' },
        { key: 'EXPO_NO_DOCTOR', value: '1' },
        { key: 'NODE_OPTIONS', value: '--dns-result-order=ipv4first' }
    ];

    let updated = false;

    envVars.forEach(({ key, value }) => {
        if (!envContent.includes(`${key}=`)) {
            envContent += `\n# Fix for Expo fetch errors\n${key}=${value}\n`;
            console.log(`‚úÖ Added ${key}=${value} to .env`);
            updated = true;
        }
    });

    if (updated) {
        fs.writeFileSync(envPath, envContent);
    } else {
        console.log('‚úÖ .env file already has the required variables');
    }
} catch (err) {
    console.error('‚ùå Error updating .env file:', err.message);
}

// 3. Create app.config.js to override doctor settings
console.log('\nüîß Creating app.config.js to override Expo doctor settings...');
const appConfigPath = path.join(__dirname, 'app.config.js');

try {
    const appConfigContent = `// Generated by fix-expo-completely.js
// This file overrides settings in app.json
const { getDefaultConfig } = require('@expo/config');

module.exports = ({ config }) => {
  // Get the default config first
  const defaultConfig = getDefaultConfig(__dirname);
  
  // Override with our custom settings
  return {
    ...defaultConfig,
    ...config,
    // Add or override doctor settings
    doctor: {
      ...(config.doctor || {}),
      checkNpmPackages: false,
      checkExpoSdkVersions: false,
      checkVirtualizedLists: false,
      checkMissingDependencies: false,
      checkDependencyVersions: false,
      checkNativeModules: false
    }
  };
};
`;

    fs.writeFileSync(appConfigPath, appConfigContent);
    console.log('‚úÖ Created app.config.js with doctor settings disabled');
} catch (err) {
    console.error('‚ùå Error creating app.config.js:', err.message);
}

// 4. Try to directly patch the problematic file
console.log('\nüîç Looking for getNativeModuleVersions.js to patch...');

function findFile(startPath, filter) {
    if (!fs.existsSync(startPath)) return null;

    let foundPath = null;

    try {
        const files = fs.readdirSync(startPath);

        for (let file of files) {
            const filepath = path.join(startPath, file);

            try {
                const stat = fs.statSync(filepath);

                if (stat.isDirectory()) {
                    const found = findFile(filepath, filter);
                    if (found) return found;
                } else if (file === filter || file.includes(filter)) {
                    return filepath;
                }
            } catch (err) {
                // Skip any file access errors
            }
        }
    } catch (err) {
        // Skip directory access errors
    }

    return null;
}

const nodeModulesPath = path.resolve(__dirname, 'node_modules');
const targetFile = findFile(nodeModulesPath, 'getNativeModuleVersions.js');

if (targetFile) {
    console.log(`üìÑ Found target file: ${targetFile}`);

    try {
        // Read the file content
        let fileContent = fs.readFileSync(targetFile, 'utf8');

        // Check if the file has already been patched
        if (fileContent.includes('// PATCHED FOR BODY IS UNUSABLE ERROR')) {
            console.log('‚úÖ File has already been patched.');
        } else if (fileContent.includes('response.json()')) {
            console.log('üî® Patching file to handle "Body is unusable" error...');

            // Replace the problematic code with a wrapped version
            fileContent = fileContent.replace(
                /(\s*)(const result = await response\.json\(\);)/g,
                `$1// PATCHED FOR BODY IS UNUSABLE ERROR
$1let result;
$1try {
$1  $2
$1} catch (error) {
$1  console.warn('Error parsing response JSON, using fallback:', error.message);
$1  result = { 
$1    expoModules: {},
$1    modules: {},
$1    sdkVersions: {} 
$1  };
$1}`
            );

            // Create a backup of the original file
            const backupPath = `${targetFile}.backup`;
            fs.writeFileSync(backupPath, fs.readFileSync(targetFile));
            console.log(`üìë Created backup at: ${backupPath}`);

            // Write the patched file
            fs.writeFileSync(targetFile, fileContent);
            console.log('‚úÖ Patch applied successfully!');
        } else {
            console.log('‚ùì File structure doesn\'t match expected pattern - skipping direct patch.');
        }
    } catch (err) {
        console.error('‚ùå Error patching file:', err.message);
    }
} else {
    console.log('‚ùì Could not find getNativeModuleVersions.js file - skipping direct patch.');
}

console.log('\nüöÄ All fixes have been applied! Try running "npm start" again.');
console.log('If you still encounter issues, try:\n');
console.log('1. npm run start-offline');
console.log('2. Node.js version 16.20.2 using NVM');
console.log('3. Reinstall node_modules with: rm -rf node_modules && npm install');
console.log('\n‚úÖ Fix complete!'); 