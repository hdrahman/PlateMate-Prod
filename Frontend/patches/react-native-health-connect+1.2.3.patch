diff --git a/node_modules/react-native-health-connect/android/.project b/node_modules/react-native-health-connect/android/.project
new file mode 100644
index 0000000..1e8fde4
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>react-native-health-connect</name>
+	<comment>Project react-native-health-connect created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1766301866899</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/react-native-health-connect/android/bin/.project b/node_modules/react-native-health-connect/android/bin/.project
new file mode 100644
index 0000000..1e8fde4
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>react-native-health-connect</name>
+	<comment>Project react-native-health-connect created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1766301866899</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/react-native-health-connect/android/bin/build.gradle b/node_modules/react-native-health-connect/android/bin/build.gradle
new file mode 100644
index 0000000..49e4835
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build.gradle
@@ -0,0 +1,103 @@
+buildscript {
+  // Buildscript is evaluated before everything else so we can't use getExtOrDefault
+  def kotlin_version = rootProject.ext.has("kotlinVersion") ? rootProject.ext.get("kotlinVersion") : project.properties["HealthConnect_kotlinVersion"]
+
+  repositories {
+    google()
+    mavenCentral()
+  }
+
+  dependencies {
+    classpath "com.android.tools.build:gradle:7.2.1"
+    // noinspection DifferentKotlinGradleVersion
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+  }
+}
+
+def isNewArchitectureEnabled() {
+  return rootProject.hasProperty("newArchEnabled") && rootProject.getProperty("newArchEnabled") == "true"
+}
+
+apply plugin: "com.android.library"
+apply plugin: "kotlin-android"
+
+if (isNewArchitectureEnabled()) {
+  apply plugin: "com.facebook.react"
+}
+
+def getExtOrDefault(name) {
+  return rootProject.ext.has(name) ? rootProject.ext.get(name) : project.properties["HealthConnect_" + name]
+}
+
+def getExtOrIntegerDefault(name) {
+  return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties["HealthConnect_" + name]).toInteger()
+}
+
+android {
+  def agpVersion = com.android.Version.ANDROID_GRADLE_PLUGIN_VERSION
+  // Check AGP version for backward compatibility reasons
+  if (agpVersion.tokenize('.')[0].toInteger() >= 7) {
+      namespace = "dev.matinzd.healthconnect"
+  }
+
+  compileSdkVersion getExtOrIntegerDefault("compileSdkVersion")
+
+  defaultConfig {
+    minSdkVersion getExtOrIntegerDefault("minSdkVersion")
+    targetSdkVersion getExtOrIntegerDefault("targetSdkVersion")
+    buildConfigField "boolean", "IS_NEW_ARCHITECTURE_ENABLED", isNewArchitectureEnabled().toString()
+  }
+  buildTypes {
+    release {
+      minifyEnabled false
+    }
+  }
+
+  lintOptions {
+    disable "GradleCompatible"
+  }
+
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  sourceSets {
+    main {
+      if (isNewArchitectureEnabled()) {
+        java.srcDirs += [
+          "src/newarch",
+          // This is needed to build Kotlin project with NewArch enabled
+          "${project.buildDir}/generated/source/codegen/java"
+        ]
+      } else {
+        java.srcDirs += ["src/oldarch"]
+      }
+    }
+  }
+}
+
+repositories {
+  mavenCentral()
+  google()
+}
+
+def kotlin_version = getExtOrDefault("kotlinVersion")
+
+dependencies {
+  // For < 0.71, this will be from the local maven repo
+  // For > 0.71, this will be replaced by `com.facebook.react:react-android:$version` by react gradle plugin
+  //noinspection GradleDynamicVersion
+  implementation "com.facebook.react:react-native"
+  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
+  implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
+  implementation "androidx.health.connect:connect-client:1.1.0-alpha06"
+}
+
+if (isNewArchitectureEnabled()) {
+  react {
+    jsRootDir = file("../src/")
+    libraryName = "HealthConnect"
+    codegenJavaPackageName = "dev.matinzd.healthconnect"
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/buildConfig/release/dev/matinzd/healthconnect/BuildConfig.class b/node_modules/react-native-health-connect/android/bin/build/generated/source/buildConfig/release/dev/matinzd/healthconnect/BuildConfig.class
new file mode 100644
index 0000000..4ad1371
Binary files /dev/null and b/node_modules/react-native-health-connect/android/bin/build/generated/source/buildConfig/release/dev/matinzd/healthconnect/BuildConfig.class differ
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/java/dev/matinzd/healthconnect/NativeHealthConnectSpec.class b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/java/dev/matinzd/healthconnect/NativeHealthConnectSpec.class
new file mode 100644
index 0000000..a929177
Binary files /dev/null and b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/java/dev/matinzd/healthconnect/NativeHealthConnectSpec.class differ
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/CMakeLists.txt b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/CMakeLists.txt
new file mode 100644
index 0000000..5701996
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/CMakeLists.txt
@@ -0,0 +1,28 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+cmake_minimum_required(VERSION 3.13)
+set(CMAKE_VERBOSE_MAKEFILE on)
+
+file(GLOB react_codegen_SRCS CONFIGURE_DEPENDS *.cpp react/renderer/components/RNHealthConnectSpec/*.cpp)
+
+add_library(
+  react_codegen_RNHealthConnectSpec
+  OBJECT
+  ${react_codegen_SRCS}
+)
+
+target_include_directories(react_codegen_RNHealthConnectSpec PUBLIC . react/renderer/components/RNHealthConnectSpec)
+
+target_link_libraries(
+  react_codegen_RNHealthConnectSpec
+  fbjni
+  jsi
+  # We need to link different libraries based on whether we are building rncore or not, that's necessary
+  # because we want to break a circular dependency between react_codegen_rncore and reactnative
+  reactnative
+)
+
+target_compile_reactnative_options(react_codegen_RNHealthConnectSpec PRIVATE)
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/RNHealthConnectSpec-generated.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/RNHealthConnectSpec-generated.cpp
new file mode 100644
index 0000000..5551d5f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/RNHealthConnectSpec-generated.cpp
@@ -0,0 +1,104 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniCpp.js
+ */
+
+#include "RNHealthConnectSpec.h"
+
+namespace facebook::react {
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_getSdkStatus(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getSdkStatus", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_initialize(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "initialize", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectSettings(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "openHealthConnectSettings", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectDataManagement(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "openHealthConnectDataManagement", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_requestPermission(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "requestPermission", "(Lcom/facebook/react/bridge/ReadableArray;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_getGrantedPermissions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getGrantedPermissions", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_revokeAllPermissions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "revokeAllPermissions", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_insertRecords(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "insertRecords", "(Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_readRecords(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "readRecords", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_readRecord(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "readRecord", "(Ljava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_aggregateRecord(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "aggregateRecord", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByUuids(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "deleteRecordsByUuids", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByTimeRange(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "deleteRecordsByTimeRange", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeHealthConnectSpecJSI::NativeHealthConnectSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getSdkStatus"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_getSdkStatus};
+  methodMap_["initialize"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_initialize};
+  methodMap_["openHealthConnectSettings"] = MethodMetadata {0, __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectSettings};
+  methodMap_["openHealthConnectDataManagement"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectDataManagement};
+  methodMap_["requestPermission"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_requestPermission};
+  methodMap_["getGrantedPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectSpecJSI_getGrantedPermissions};
+  methodMap_["revokeAllPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectSpecJSI_revokeAllPermissions};
+  methodMap_["insertRecords"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_insertRecords};
+  methodMap_["readRecords"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_readRecords};
+  methodMap_["readRecord"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_readRecord};
+  methodMap_["aggregateRecord"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_aggregateRecord};
+  methodMap_["deleteRecordsByUuids"] = MethodMetadata {3, __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByUuids};
+  methodMap_["deleteRecordsByTimeRange"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByTimeRange};
+}
+
+std::shared_ptr<TurboModule> RNHealthConnectSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params) {
+  if (moduleName == "HealthConnect") {
+    return std::make_shared<NativeHealthConnectSpecJSI>(params);
+  }
+  return nullptr;
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/RNHealthConnectSpec.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/RNHealthConnectSpec.h
new file mode 100644
index 0000000..d5227b1
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/RNHealthConnectSpec.h
@@ -0,0 +1,31 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/JavaTurboModule.h>
+#include <ReactCommon/TurboModule.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+/**
+ * JNI C++ class for module 'NativeHealthConnect'
+ */
+class JSI_EXPORT NativeHealthConnectSpecJSI : public JavaTurboModule {
+public:
+  NativeHealthConnectSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+
+JSI_EXPORT
+std::shared_ptr<TurboModule> RNHealthConnectSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.cpp
new file mode 100644
index 0000000..29db675
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.cpp
@@ -0,0 +1,22 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+void RNHealthConnectSpec_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry) {
+
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h
new file mode 100644
index 0000000..87d5756
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h
@@ -0,0 +1,24 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/RNHealthConnectSpec/ShadowNodes.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+
+
+void RNHealthConnectSpec_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.cpp
new file mode 100644
index 0000000..f7c4764
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/EventEmitters.h>
+
+
+namespace facebook::react {
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.h
new file mode 100644
index 0000000..2845a63
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.h
@@ -0,0 +1,17 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewEventEmitter.h>
+
+
+namespace facebook::react {
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.cpp
new file mode 100644
index 0000000..322a5d3
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.cpp
@@ -0,0 +1,19 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/Props.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/core/propsConversions.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.h
new file mode 100644
index 0000000..870864b
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.h
@@ -0,0 +1,18 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsH.js
+ */
+#pragma once
+
+
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI-generated.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI-generated.cpp
new file mode 100644
index 0000000..55a5d58
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI-generated.cpp
@@ -0,0 +1,116 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleCpp.js
+ */
+
+#include "RNHealthConnectSpecJSI.h"
+
+namespace facebook::react {
+
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_getSdkStatus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->getSdkStatus(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_initialize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->initialize(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->openHealthConnectSettings(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectDataManagement(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->openHealthConnectDataManagement(
+    rt,
+    count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt))
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_requestPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->requestPermission(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_getGrantedPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->getGrantedPermissions(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_revokeAllPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->revokeAllPermissions(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_insertRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->insertRecords(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_readRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->readRecords(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_readRecord(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->readRecord(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_aggregateRecord(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->aggregateRecord(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByUuids(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->deleteRecordsByUuids(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByTimeRange(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->deleteRecordsByTimeRange(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+
+NativeHealthConnectCxxSpecJSI::NativeHealthConnectCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("HealthConnect", jsInvoker) {
+  methodMap_["getSdkStatus"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_getSdkStatus};
+  methodMap_["initialize"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_initialize};
+  methodMap_["openHealthConnectSettings"] = MethodMetadata {0, __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectSettings};
+  methodMap_["openHealthConnectDataManagement"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectDataManagement};
+  methodMap_["requestPermission"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_requestPermission};
+  methodMap_["getGrantedPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectCxxSpecJSI_getGrantedPermissions};
+  methodMap_["revokeAllPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectCxxSpecJSI_revokeAllPermissions};
+  methodMap_["insertRecords"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_insertRecords};
+  methodMap_["readRecords"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_readRecords};
+  methodMap_["readRecord"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_readRecord};
+  methodMap_["aggregateRecord"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_aggregateRecord};
+  methodMap_["deleteRecordsByUuids"] = MethodMetadata {3, __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByUuids};
+  methodMap_["deleteRecordsByTimeRange"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByTimeRange};
+}
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI.h
new file mode 100644
index 0000000..98666c2
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI.h
@@ -0,0 +1,262 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/TurboModule.h>
+#include <react/bridging/Bridging.h>
+
+namespace facebook::react {
+
+
+  
+#pragma mark - NativeHealthConnectReadRecordsOptions
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+struct NativeHealthConnectReadRecordsOptions {
+  P0 startTime;
+  P1 endTime;
+  P2 dataOriginFilter;
+  P3 ascendingOrder;
+  P4 pageSize;
+  P5 pageToken;
+  bool operator==(const NativeHealthConnectReadRecordsOptions &other) const {
+    return startTime == other.startTime && endTime == other.endTime && dataOriginFilter == other.dataOriginFilter && ascendingOrder == other.ascendingOrder && pageSize == other.pageSize && pageToken == other.pageToken;
+  }
+};
+
+template <typename T>
+struct NativeHealthConnectReadRecordsOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.startTime)>(rt, value.getProperty(rt, "startTime"), jsInvoker),
+      bridging::fromJs<decltype(types.endTime)>(rt, value.getProperty(rt, "endTime"), jsInvoker),
+      bridging::fromJs<decltype(types.dataOriginFilter)>(rt, value.getProperty(rt, "dataOriginFilter"), jsInvoker),
+      bridging::fromJs<decltype(types.ascendingOrder)>(rt, value.getProperty(rt, "ascendingOrder"), jsInvoker),
+      bridging::fromJs<decltype(types.pageSize)>(rt, value.getProperty(rt, "pageSize"), jsInvoker),
+      bridging::fromJs<decltype(types.pageToken)>(rt, value.getProperty(rt, "pageToken"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String startTimeToJs(jsi::Runtime &rt, decltype(types.startTime) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String endTimeToJs(jsi::Runtime &rt, decltype(types.endTime) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array dataOriginFilterToJs(jsi::Runtime &rt, decltype(types.dataOriginFilter) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool ascendingOrderToJs(jsi::Runtime &rt, decltype(types.ascendingOrder) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double pageSizeToJs(jsi::Runtime &rt, decltype(types.pageSize) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String pageTokenToJs(jsi::Runtime &rt, decltype(types.pageToken) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
+    result.setProperty(rt, "endTime", bridging::toJs(rt, value.endTime, jsInvoker));
+    if (value.dataOriginFilter) {
+      result.setProperty(rt, "dataOriginFilter", bridging::toJs(rt, value.dataOriginFilter.value(), jsInvoker));
+    }
+    if (value.ascendingOrder) {
+      result.setProperty(rt, "ascendingOrder", bridging::toJs(rt, value.ascendingOrder.value(), jsInvoker));
+    }
+    if (value.pageSize) {
+      result.setProperty(rt, "pageSize", bridging::toJs(rt, value.pageSize.value(), jsInvoker));
+    }
+    if (value.pageToken) {
+      result.setProperty(rt, "pageToken", bridging::toJs(rt, value.pageToken.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeHealthConnectCxxSpecJSI : public TurboModule {
+protected:
+  NativeHealthConnectCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getSdkStatus(jsi::Runtime &rt, jsi::String providerPackageName) = 0;
+  virtual jsi::Value initialize(jsi::Runtime &rt, jsi::String providerPackageName) = 0;
+  virtual void openHealthConnectSettings(jsi::Runtime &rt) = 0;
+  virtual void openHealthConnectDataManagement(jsi::Runtime &rt, std::optional<jsi::String> providerPackageName) = 0;
+  virtual jsi::Value requestPermission(jsi::Runtime &rt, jsi::Array permissions, jsi::String providerPackageName) = 0;
+  virtual jsi::Value getGrantedPermissions(jsi::Runtime &rt) = 0;
+  virtual jsi::Value revokeAllPermissions(jsi::Runtime &rt) = 0;
+  virtual jsi::Value insertRecords(jsi::Runtime &rt, jsi::Array records) = 0;
+  virtual jsi::Value readRecords(jsi::Runtime &rt, jsi::String recordType, jsi::Object options) = 0;
+  virtual jsi::Value readRecord(jsi::Runtime &rt, jsi::String recordType, jsi::String recordId) = 0;
+  virtual jsi::Value aggregateRecord(jsi::Runtime &rt, jsi::Object record) = 0;
+  virtual jsi::Value deleteRecordsByUuids(jsi::Runtime &rt, jsi::String recordType, jsi::Array recordIdsList, jsi::Array clientRecordIdsList) = 0;
+  virtual jsi::Value deleteRecordsByTimeRange(jsi::Runtime &rt, jsi::String recordType, jsi::Object timeRangeFilter) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeHealthConnectCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "HealthConnect";
+
+protected:
+  NativeHealthConnectCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeHealthConnectCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeHealthConnectCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeHealthConnectCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getSdkStatus(jsi::Runtime &rt, jsi::String providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSdkStatus) == 2,
+          "Expected getSdkStatus(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getSdkStatus, jsInvoker_, instance_, std::move(providerPackageName));
+    }
+    jsi::Value initialize(jsi::Runtime &rt, jsi::String providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::initialize) == 2,
+          "Expected initialize(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::initialize, jsInvoker_, instance_, std::move(providerPackageName));
+    }
+    void openHealthConnectSettings(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::openHealthConnectSettings) == 1,
+          "Expected openHealthConnectSettings(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::openHealthConnectSettings, jsInvoker_, instance_);
+    }
+    void openHealthConnectDataManagement(jsi::Runtime &rt, std::optional<jsi::String> providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::openHealthConnectDataManagement) == 2,
+          "Expected openHealthConnectDataManagement(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::openHealthConnectDataManagement, jsInvoker_, instance_, std::move(providerPackageName));
+    }
+    jsi::Value requestPermission(jsi::Runtime &rt, jsi::Array permissions, jsi::String providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::requestPermission) == 3,
+          "Expected requestPermission(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::requestPermission, jsInvoker_, instance_, std::move(permissions), std::move(providerPackageName));
+    }
+    jsi::Value getGrantedPermissions(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getGrantedPermissions) == 1,
+          "Expected getGrantedPermissions(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getGrantedPermissions, jsInvoker_, instance_);
+    }
+    jsi::Value revokeAllPermissions(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::revokeAllPermissions) == 1,
+          "Expected revokeAllPermissions(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::revokeAllPermissions, jsInvoker_, instance_);
+    }
+    jsi::Value insertRecords(jsi::Runtime &rt, jsi::Array records) override {
+      static_assert(
+          bridging::getParameterCount(&T::insertRecords) == 2,
+          "Expected insertRecords(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::insertRecords, jsInvoker_, instance_, std::move(records));
+    }
+    jsi::Value readRecords(jsi::Runtime &rt, jsi::String recordType, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::readRecords) == 3,
+          "Expected readRecords(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::readRecords, jsInvoker_, instance_, std::move(recordType), std::move(options));
+    }
+    jsi::Value readRecord(jsi::Runtime &rt, jsi::String recordType, jsi::String recordId) override {
+      static_assert(
+          bridging::getParameterCount(&T::readRecord) == 3,
+          "Expected readRecord(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::readRecord, jsInvoker_, instance_, std::move(recordType), std::move(recordId));
+    }
+    jsi::Value aggregateRecord(jsi::Runtime &rt, jsi::Object record) override {
+      static_assert(
+          bridging::getParameterCount(&T::aggregateRecord) == 2,
+          "Expected aggregateRecord(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::aggregateRecord, jsInvoker_, instance_, std::move(record));
+    }
+    jsi::Value deleteRecordsByUuids(jsi::Runtime &rt, jsi::String recordType, jsi::Array recordIdsList, jsi::Array clientRecordIdsList) override {
+      static_assert(
+          bridging::getParameterCount(&T::deleteRecordsByUuids) == 4,
+          "Expected deleteRecordsByUuids(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::deleteRecordsByUuids, jsInvoker_, instance_, std::move(recordType), std::move(recordIdsList), std::move(clientRecordIdsList));
+    }
+    jsi::Value deleteRecordsByTimeRange(jsi::Runtime &rt, jsi::String recordType, jsi::Object timeRangeFilter) override {
+      static_assert(
+          bridging::getParameterCount(&T::deleteRecordsByTimeRange) == 3,
+          "Expected deleteRecordsByTimeRange(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::deleteRecordsByTimeRange, jsInvoker_, instance_, std::move(recordType), std::move(timeRangeFilter));
+    }
+
+  private:
+    friend class NativeHealthConnectCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.cpp
new file mode 100644
index 0000000..afa35d4
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.cpp
@@ -0,0 +1,17 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/ShadowNodes.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.h
new file mode 100644
index 0000000..84de0bc
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.h
@@ -0,0 +1,23 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/RNHealthConnectSpec/EventEmitters.h>
+#include <react/renderer/components/RNHealthConnectSpec/Props.h>
+#include <react/renderer/components/RNHealthConnectSpec/States.h>
+#include <react/renderer/components/view/ConcreteViewShadowNode.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.cpp b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.cpp
new file mode 100644
index 0000000..248aefe
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateCpp.js
+ */
+#include <react/renderer/components/RNHealthConnectSpec/States.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.h b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.h
new file mode 100644
index 0000000..2e55bce
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.h
@@ -0,0 +1,20 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateH.js
+ */
+#pragma once
+
+#include <react/renderer/core/StateData.h>
+#ifdef RN_SERIALIZABLE_STATE
+#include <folly/dynamic.h>
+#endif
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/schema.json b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/schema.json
new file mode 100644
index 0000000..f192e5e
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/generated/source/codegen/schema.json
@@ -0,0 +1 @@
+{"libraryName":"","modules":{"NativeHealthConnect":{"type":"NativeModule","aliasMap":{"ReadRecordsOptions":{"type":"ObjectTypeAnnotation","properties":[{"name":"startTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"endTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"dataOriginFilter","optional":true,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}},{"name":"ascendingOrder","optional":true,"typeAnnotation":{"type":"BooleanTypeAnnotation"}},{"name":"pageSize","optional":true,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"pageToken","optional":true,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"getSdkStatus","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}},"params":[{"name":"providerPackageName","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"initialize","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"BooleanTypeAnnotation"}},"params":[{"name":"providerPackageName","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"openHealthConnectSettings","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[]}},{"name":"openHealthConnectDataManagement","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"providerPackageName","optional":true,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"requestPermission","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},"params":[{"name":"permissions","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},{"name":"providerPackageName","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"getGrantedPermissions","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},"params":[]}},{"name":"revokeAllPermissions","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[]}},{"name":"insertRecords","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}},"params":[{"name":"records","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}}]}},{"name":"readRecords","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"ObjectTypeAnnotation","properties":[]}}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"options","optional":false,"typeAnnotation":{"type":"TypeAliasTypeAnnotation","name":"ReadRecordsOptions"}}]}},{"name":"readRecord","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ObjectTypeAnnotation","properties":[]}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"recordId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"aggregateRecord","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ObjectTypeAnnotation","properties":[]}},"params":[{"name":"record","optional":false,"typeAnnotation":{"type":"ObjectTypeAnnotation","properties":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"startTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"endTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}]}},{"name":"deleteRecordsByUuids","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"recordIdsList","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}},{"name":"clientRecordIdsList","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}}]}},{"name":"deleteRecordsByTimeRange","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"timeRangeFilter","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}}]}}]},"moduleName":"HealthConnect"}}}
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/bin/build/intermediates/incremental/mergeReleaseJniLibFolders/merger.xml b/node_modules/react-native-health-connect/android/bin/build/intermediates/incremental/mergeReleaseJniLibFolders/merger.xml
new file mode 100644
index 0000000..b8f71f0
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/build/intermediates/incremental/mergeReleaseJniLibFolders/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\jniLibs"/></dataSet><dataSet config="release" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\release\jniLibs"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/bin/gradle.properties b/node_modules/react-native-health-connect/android/bin/gradle.properties
new file mode 100644
index 0000000..81f310f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/gradle.properties
@@ -0,0 +1,5 @@
+HealthConnect_kotlinVersion=1.8.0
+HealthConnect_minSdkVersion=26
+HealthConnect_targetSdkVersion=34
+HealthConnect_compileSdkVersion=34
+HealthConnect_ndkversion=21.4.7075529
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/AndroidManifest.xml b/node_modules/react-native-health-connect/android/bin/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..232489d
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dev.matinzd.healthconnect">
+
+  <queries>
+    <package android:name="com.google.android.apps.healthdata" />
+  </queries>
+
+</manifest>
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt
new file mode 100644
index 0000000..58cc146
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt
@@ -0,0 +1,217 @@
+package dev.matinzd.healthconnect
+
+import android.app.Activity
+import android.content.Intent
+import android.os.Bundle
+import androidx.health.connect.client.HealthConnectClient
+import com.facebook.react.bridge.ActivityEventListener
+import com.facebook.react.bridge.Promise
+import com.facebook.react.bridge.ReactApplicationContext
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import dev.matinzd.healthconnect.permissions.HCPermissionManager
+import dev.matinzd.healthconnect.records.ReactHealthRecord
+import dev.matinzd.healthconnect.utils.ClientNotInitialized
+import dev.matinzd.healthconnect.utils.getTimeRangeFilter
+import dev.matinzd.healthconnect.utils.reactRecordTypeToClassMap
+import dev.matinzd.healthconnect.utils.rejectWithException
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+
+class HealthConnectManager(private val applicationContext: ReactApplicationContext) :
+  ActivityEventListener {
+  private lateinit var healthConnectClient: HealthConnectClient
+  private val coroutineScope = CoroutineScope(Dispatchers.IO)
+  private var pendingPromise: Promise? = null
+  private var latestPermissions: Set<String>? = null
+
+  private val isInitialized get() = this::healthConnectClient.isInitialized
+
+  private inline fun throwUnlessClientIsAvailable(promise: Promise, block: () -> Unit) {
+    if (!isInitialized) {
+      return promise.rejectWithException(ClientNotInitialized())
+    }
+    block()
+  }
+
+  override fun onActivityResult(activity: Activity, requestCode: Int, resultCode: Int, data: Intent?) {
+    if (requestCode == REQUEST_CODE) {
+      HCPermissionManager.parseOnActivityResult(resultCode, data, pendingPromise)
+    }
+  }
+
+  override fun onNewIntent(intent: Intent?) {}
+
+  fun openHealthConnectSettings() {
+    val intent = Intent(HealthConnectClient.ACTION_HEALTH_CONNECT_SETTINGS)
+    applicationContext.currentActivity?.startActivity(intent)
+  }
+
+  fun openHealthConnectDataManagement(providerPackageName: String?) {
+    val intent = providerPackageName?.let {
+      HealthConnectClient.getHealthConnectManageDataIntent(applicationContext, it)
+    } ?: HealthConnectClient.getHealthConnectManageDataIntent(applicationContext)
+    applicationContext.currentActivity?.startActivity(intent)
+  }
+
+  fun getSdkStatus(providerPackageName: String, promise: Promise) {
+    val status = HealthConnectClient.getSdkStatus(applicationContext, providerPackageName)
+    return promise.resolve(status)
+  }
+
+  fun initialize(providerPackageName: String, promise: Promise) {
+    try {
+      healthConnectClient = HealthConnectClient.getOrCreate(applicationContext, providerPackageName)
+      promise.resolve(true)
+    } catch (e: Exception) {
+      promise.rejectWithException(e)
+    }
+  }
+
+  fun requestPermission(
+    reactPermissions: ReadableArray, providerPackageName: String, promise: Promise
+  ) {
+    throwUnlessClientIsAvailable(promise) {
+      this.pendingPromise = promise
+      this.latestPermissions = HCPermissionManager.parsePermissions(reactPermissions)
+
+      val bundle = Bundle().apply {
+        putString("providerPackageName", providerPackageName)
+      }
+
+      val intent = HCPermissionManager(providerPackageName).healthPermissionContract.createIntent(
+        applicationContext, latestPermissions!!
+      )
+
+      applicationContext.currentActivity?.startActivityForResult(
+        intent,
+        HealthConnectManager.REQUEST_CODE,
+        bundle
+      )
+    }
+  }
+
+  fun revokeAllPermissions(promise: Promise) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        healthConnectClient.permissionController.revokeAllPermissions()
+      }
+    }
+  }
+
+  fun getGrantedPermissions(promise: Promise) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        promise.resolve(HCPermissionManager.getGrantedPermissions(healthConnectClient.permissionController))
+      }
+    }
+  }
+
+  fun insertRecords(reactRecords: ReadableArray, promise: Promise) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        try {
+          val records = ReactHealthRecord.parseWriteRecords(reactRecords)
+          val response = healthConnectClient.insertRecords(records)
+          promise.resolve(ReactHealthRecord.parseWriteResponse(response))
+        } catch (e: Exception) {
+          promise.rejectWithException(e)
+        }
+      }
+    }
+  }
+
+  fun readRecords(recordType: String, options: ReadableMap, promise: Promise) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        try {
+          val request = ReactHealthRecord.parseReadRequest(recordType, options)
+          val response = healthConnectClient.readRecords(request)
+          promise.resolve(ReactHealthRecord.parseRecords(recordType, response))
+        } catch (e: Exception) {
+          promise.rejectWithException(e)
+        }
+      }
+    }
+  }
+
+  fun readRecord(recordType: String, recordId: String, promise: Promise) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        try {
+          val record = ReactHealthRecord.getRecordByType(recordType)
+          val response = healthConnectClient.readRecord(record, recordId)
+          promise.resolve(ReactHealthRecord.parseRecord(recordType, response))
+        } catch (e: Exception) {
+          promise.rejectWithException(e)
+        }
+      }
+    }
+  }
+
+  fun aggregateRecord(record: ReadableMap, promise: Promise) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        try {
+          val recordType = record.getString("recordType") ?: ""
+          val response = healthConnectClient.aggregate(
+            ReactHealthRecord.getAggregateRequest(
+              recordType, record
+            )
+          )
+          promise.resolve(ReactHealthRecord.parseAggregationResult(recordType, response))
+        } catch (e: Exception) {
+          promise.rejectWithException(e)
+        }
+      }
+    }
+  }
+
+  fun deleteRecordsByUuids(
+    recordType: String,
+    recordIdsList: ReadableArray,
+    clientRecordIdsList: ReadableArray,
+    promise: Promise
+  ) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        val record = reactRecordTypeToClassMap[recordType]
+        if (record != null) {
+          healthConnectClient.deleteRecords(
+            recordType = record,
+            recordIdsList = recordIdsList.toArrayList().mapNotNull { it.toString() }.toList(),
+            clientRecordIdsList = if (clientRecordIdsList.size() > 0) clientRecordIdsList.toArrayList()
+              .mapNotNull { it.toString() }.toList() else emptyList()
+          )
+        }
+      }
+    }
+  }
+
+  fun deleteRecordsByTimeRange(
+    recordType: String, timeRangeFilter: ReadableMap, promise: Promise
+  ) {
+    throwUnlessClientIsAvailable(promise) {
+      coroutineScope.launch {
+        val record = reactRecordTypeToClassMap[recordType]
+        if (record != null) {
+          healthConnectClient.deleteRecords(
+            recordType = record, timeRangeFilter = timeRangeFilter.getTimeRangeFilter()
+          )
+        }
+      }
+    }
+  }
+
+  companion object {
+    const val REQUEST_CODE = 4235
+  }
+
+  init {
+    applicationContext.addActivityEventListener(this)
+  }
+}
+
+
+
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectModule.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectModule.kt
new file mode 100644
index 0000000..56d423c
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectModule.kt
@@ -0,0 +1,95 @@
+package dev.matinzd.healthconnect
+
+import com.facebook.react.bridge.*
+
+class HealthConnectModule internal constructor(context: ReactApplicationContext) :
+  HealthConnectSpec(context) {
+
+  private val manager = HealthConnectManager(context)
+
+  override fun getName(): String {
+    return NAME
+  }
+
+  @ReactMethod
+  override fun getSdkStatus(providerPackageName: String, promise: Promise) {
+    return manager.getSdkStatus(providerPackageName, promise)
+  }
+
+  @ReactMethod
+  override fun openHealthConnectSettings() {
+    manager.openHealthConnectSettings()
+  }
+
+  @ReactMethod
+  override fun openHealthConnectDataManagement(providerPackageName: String?) {
+    manager.openHealthConnectDataManagement(providerPackageName)
+  }
+
+  @ReactMethod
+  override fun initialize(providerPackageName: String, promise: Promise) {
+    return manager.initialize(providerPackageName, promise)
+  }
+
+  @ReactMethod
+  override fun requestPermission(
+    permissions: ReadableArray,
+    providerPackageName: String,
+    promise: Promise
+  ) {
+    return manager.requestPermission(permissions, providerPackageName, promise)
+  }
+
+  @ReactMethod
+  override fun getGrantedPermissions(promise: Promise) {
+    return manager.getGrantedPermissions(promise)
+  }
+
+  @ReactMethod
+  override fun revokeAllPermissions(promise: Promise) {
+    return manager.revokeAllPermissions(promise)
+  }
+
+  @ReactMethod
+  override fun insertRecords(records: ReadableArray, promise: Promise) {
+    return manager.insertRecords(records, promise)
+  }
+
+  @ReactMethod
+  override fun readRecords(recordType: String, options: ReadableMap, promise: Promise) {
+    return manager.readRecords(recordType, options, promise)
+  }
+
+  @ReactMethod
+  override fun readRecord(recordType: String, recordId: String, promise: Promise) {
+    return manager.readRecord(recordType, recordId, promise)
+  }
+
+  @ReactMethod
+  override fun aggregateRecord(record: ReadableMap, promise: Promise) {
+    return manager.aggregateRecord(record, promise)
+  }
+
+  @ReactMethod
+  override fun deleteRecordsByUuids(
+    recordType: String,
+    recordIdsList: ReadableArray,
+    clientRecordIdsList: ReadableArray,
+    promise: Promise
+  ) {
+    return manager.deleteRecordsByUuids(recordType, recordIdsList, clientRecordIdsList, promise)
+  }
+
+  @ReactMethod
+  override fun deleteRecordsByTimeRange(
+    recordType: String,
+    timeRangeFilter: ReadableMap,
+    promise: Promise
+  ) {
+    return manager.deleteRecordsByTimeRange(recordType, timeRangeFilter, promise)
+  }
+
+  companion object {
+    const val NAME = "HealthConnect"
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectPackage.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectPackage.kt
new file mode 100644
index 0000000..340a9d5
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/HealthConnectPackage.kt
@@ -0,0 +1,35 @@
+package dev.matinzd.healthconnect
+
+import com.facebook.react.TurboReactPackage
+import com.facebook.react.bridge.ReactApplicationContext
+import com.facebook.react.bridge.NativeModule
+import com.facebook.react.module.model.ReactModuleInfoProvider
+import com.facebook.react.module.model.ReactModuleInfo
+import java.util.HashMap
+
+class HealthConnectPackage : TurboReactPackage() {
+  override fun getModule(name: String, reactContext: ReactApplicationContext): NativeModule? {
+    return if (name == HealthConnectModule.NAME) {
+      HealthConnectModule(reactContext)
+    } else {
+      null
+    }
+  }
+
+  override fun getReactModuleInfoProvider(): ReactModuleInfoProvider {
+    return ReactModuleInfoProvider {
+      val moduleInfos: MutableMap<String, ReactModuleInfo> = HashMap()
+      val isTurboModule: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
+      moduleInfos[HealthConnectModule.NAME] = ReactModuleInfo(
+        HealthConnectModule.NAME,
+        HealthConnectModule.NAME,
+        false,  // canOverrideExistingModule
+        false,  // needsEagerInit
+        true,  // hasConstants
+        false,  // isCxxModule
+        isTurboModule // isTurboModule
+      )
+      moduleInfos
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/permissions/HCPermissionManager.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/permissions/HCPermissionManager.kt
new file mode 100644
index 0000000..0530d38
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/permissions/HCPermissionManager.kt
@@ -0,0 +1,80 @@
+package dev.matinzd.healthconnect.permissions
+
+import android.content.Intent
+import androidx.health.connect.client.PermissionController
+import androidx.health.connect.client.permission.HealthPermission
+import com.facebook.react.bridge.Promise
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.InvalidRecordType
+import dev.matinzd.healthconnect.utils.reactRecordTypeToClassMap
+
+class HCPermissionManager(providerPackageName: String) {
+  val healthPermissionContract =
+    PermissionController.createRequestPermissionResultContract(providerPackageName)
+
+  companion object {
+    private const val DEFAULT_PROVIDER_PACKAGE_NAME = "com.google.android.apps.healthdata"
+
+    fun parsePermissions(reactPermissions: ReadableArray): Set<String> {
+      return reactPermissions.toArrayList().mapNotNull {
+        it as HashMap<*, *>
+        val recordType = it["recordType"]
+        val recordClass = reactRecordTypeToClassMap[recordType]
+          ?: throw InvalidRecordType()
+
+        when (it["accessType"]) {
+          "write" -> HealthPermission.getWritePermission(recordClass)
+          "read" -> HealthPermission.getReadPermission(recordClass)
+          else -> null
+        }
+      }.toSet()
+    }
+
+    fun parseOnActivityResult(
+      resultCode: Int,
+      intent: Intent?,
+      pendingPromise: Promise?
+    ) {
+      val providerPackageName =
+        intent?.getStringExtra("providerPackageName") ?: DEFAULT_PROVIDER_PACKAGE_NAME
+      val contract = HCPermissionManager(providerPackageName).healthPermissionContract
+      val result = contract.parseResult(
+        resultCode,
+        intent
+      )
+
+      pendingPromise?.resolve(mapPermissionResult(result))
+    }
+
+    suspend fun getGrantedPermissions(permissionController: PermissionController): WritableNativeArray {
+      return mapPermissionResult(permissionController.getGrantedPermissions())
+    }
+
+    private fun mapPermissionResult(grantedPermissions: Set<String>): WritableNativeArray {
+      return WritableNativeArray().apply {
+        grantedPermissions.forEach {
+          val map = WritableNativeMap()
+
+          val (accessType, recordType) = extractPermissionResult(it)
+
+          map.putString("recordType", snakeToCamel(recordType))
+          map.putString("accessType", accessType)
+          pushMap(map)
+        }
+      }
+    }
+
+    private fun extractPermissionResult(it: String): Pair<String, String> {
+      val accessType = it.substring(it.lastIndexOf(".") + 1, it.indexOf("_")).lowercase()
+      val recordType = it.substring(it.indexOf("_") + 1).lowercase()
+      return Pair(accessType, recordType)
+    }
+
+    private fun snakeToCamel(word: String): String {
+      val components = word.split("_")
+      return components.joinToString("") { it[0].uppercase() + it.substring(1) }
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactActiveCaloriesBurnedRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactActiveCaloriesBurnedRecord.kt
new file mode 100644
index 0000000..1cc7853
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactActiveCaloriesBurnedRecord.kt
@@ -0,0 +1,66 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.ActiveCaloriesBurnedRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactActiveCaloriesBurnedRecord : ReactHealthRecordImpl<ActiveCaloriesBurnedRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<ActiveCaloriesBurnedRecord> {
+    return records.toMapList().map {
+      ActiveCaloriesBurnedRecord(
+        startTime = Instant.parse(it.getString("startTime")),
+        endTime = Instant.parse(it.getString("endTime")),
+        energy = getEnergyFromJsMap(it.getMap("energy")),
+        endZoneOffset = null,
+        startZoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: ActiveCaloriesBurnedRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("energy", energyToJsMap(record.energy))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      val map = WritableNativeMap().apply {
+        putDouble(
+          "inCalories",
+          record[ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL]?.inCalories ?: 0.0
+        )
+        putDouble(
+          "inKilojoules",
+          record[ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL]?.inKilojoules ?: 0.0
+        )
+        putDouble(
+          "inKilocalories",
+          record[ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL]?.inKilocalories ?: 0.0
+        )
+        putDouble(
+          "inJoules",
+          record[ActiveCaloriesBurnedRecord.ACTIVE_CALORIES_TOTAL]?.inJoules ?: 0.0
+        )
+      }
+      putMap("ACTIVE_CALORIES_TOTAL", map)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBasalBodyTemperatureRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBasalBodyTemperatureRecord.kt
new file mode 100644
index 0000000..264e3e4
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBasalBodyTemperatureRecord.kt
@@ -0,0 +1,65 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BasalBodyTemperatureRecord
+import androidx.health.connect.client.records.BodyTemperatureMeasurementLocation
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.Temperature
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBasalBodyTemperatureRecord : ReactHealthRecordImpl<BasalBodyTemperatureRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BasalBodyTemperatureRecord> {
+    return records.toMapList().map {
+      BasalBodyTemperatureRecord(
+        time = Instant.parse(it.getString("time")),
+        zoneOffset = null,
+        temperature = getTemperatureFromJsMap(it.getMap("temperature")),
+        measurementLocation = it.getSafeInt(
+          "measurementLocation",
+          BodyTemperatureMeasurementLocation.MEASUREMENT_LOCATION_UNKNOWN
+        )
+      )
+    }
+  }
+
+  override fun parseRecord(record: BasalBodyTemperatureRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("measurementLocation", record.measurementLocation)
+      putMap("temperature", temperatureToJsMap(record.temperature))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+
+  private fun getTemperatureFromJsMap(temperatureMap: ReadableMap?): Temperature {
+    if (temperatureMap == null) {
+      throw InvalidTemperature()
+    }
+
+    val value = temperatureMap.getDouble("value")
+    return when (temperatureMap.getString("unit")) {
+      "fahrenheit" -> Temperature.fahrenheit(value)
+      "celsius" -> Temperature.celsius(value)
+      else -> Temperature.celsius(value)
+    }
+  }
+
+  private fun temperatureToJsMap(temperature: Temperature): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("inFahrenheit", temperature.inFahrenheit)
+      putDouble("inCelsius", temperature.inCelsius)
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBasalMetabolicRateRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBasalMetabolicRateRecord.kt
new file mode 100644
index 0000000..f438f2d
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBasalMetabolicRateRecord.kt
@@ -0,0 +1,84 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BasalMetabolicRateRecord
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.Power
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBasalMetabolicRateRecord : ReactHealthRecordImpl<BasalMetabolicRateRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BasalMetabolicRateRecord> {
+    return records.toMapList().map {
+      BasalMetabolicRateRecord(
+        time = Instant.parse(it.getString("time")),
+        basalMetabolicRate = getPowerFromJsMap(it.getMap("basalMetabolicRate")),
+        zoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: BasalMetabolicRateRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("basalMetabolicRate", powerToJsMap(record.basalMetabolicRate))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(BasalMetabolicRateRecord.BASAL_CALORIES_TOTAL),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      val map = WritableNativeMap().apply {
+        putDouble(
+          "inCalories",
+          record[BasalMetabolicRateRecord.BASAL_CALORIES_TOTAL]?.inCalories ?: 0.0
+        )
+        putDouble(
+          "inKilojoules",
+          record[BasalMetabolicRateRecord.BASAL_CALORIES_TOTAL]?.inKilojoules ?: 0.0
+        )
+        putDouble(
+          "inKilocalories",
+          record[BasalMetabolicRateRecord.BASAL_CALORIES_TOTAL]?.inKilocalories ?: 0.0
+        )
+        putDouble(
+          "inJoules",
+          record[BasalMetabolicRateRecord.BASAL_CALORIES_TOTAL]?.inJoules ?: 0.0
+        )
+      }
+      putMap("BASAL_CALORIES_TOTAL", map)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+
+  private fun powerToJsMap(power: Power): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("inKilocaloriesPerDay", power.inKilocaloriesPerDay)
+      putDouble("inWatts", power.inWatts)
+    }
+  }
+
+  private fun getPowerFromJsMap(powerMap: ReadableMap?): Power {
+    if (powerMap == null) {
+      throw InvalidPower()
+    }
+
+    val value = powerMap.getDouble("value")
+    return when (powerMap.getString("unit")) {
+      "kilocaloriesPerDay" -> Power.kilocaloriesPerDay(value)
+      "watts" -> Power.watts(value)
+      else -> Power.kilocaloriesPerDay(value)
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBloodGlucoseRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBloodGlucoseRecord.kt
new file mode 100644
index 0000000..db26c6b
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBloodGlucoseRecord.kt
@@ -0,0 +1,70 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BloodGlucoseRecord
+import androidx.health.connect.client.records.MealType.MEAL_TYPE_UNKNOWN
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.BloodGlucose
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBloodGlucoseRecord : ReactHealthRecordImpl<BloodGlucoseRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BloodGlucoseRecord> {
+    return records.toMapList().map {
+      BloodGlucoseRecord(
+        time = Instant.parse(it.getString("time")),
+        level = getBloodGlucoseFromJsMap(it.getMap("level")),
+        specimenSource = it.getSafeInt(
+          "specimenSource", BloodGlucoseRecord.SPECIMEN_SOURCE_UNKNOWN
+        ),
+        mealType = it.getSafeInt("mealType", MEAL_TYPE_UNKNOWN),
+        relationToMeal = it.getSafeInt(
+          "relationToMeal", BloodGlucoseRecord.RELATION_TO_MEAL_UNKNOWN
+        ),
+        zoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: BloodGlucoseRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("level", bloodGlucoseToJsMap(record.level))
+      putInt("specimenSource", record.specimenSource)
+      putInt("mealType", record.mealType)
+      putInt("relationToMeal", record.relationToMeal)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+
+  private fun bloodGlucoseToJsMap(bloodGlucose: BloodGlucose): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("inMillimolesPerLiter", bloodGlucose.inMillimolesPerLiter)
+      putDouble("inMilligramsPerDeciliter", bloodGlucose.inMilligramsPerDeciliter)
+    }
+  }
+
+  private fun getBloodGlucoseFromJsMap(bloodGlucoseMap: ReadableMap?): BloodGlucose {
+    if (bloodGlucoseMap == null) {
+      throw InvalidBloodGlucoseLevel()
+    }
+
+    val value = bloodGlucoseMap.getDouble("value")
+    return when (bloodGlucoseMap.getString("unit")) {
+      "milligramsPerDeciliter" -> BloodGlucose.milligramsPerDeciliter(value)
+      "millimolesPerLiter" -> BloodGlucose.millimolesPerLiter(value)
+      else -> BloodGlucose.milligramsPerDeciliter(value)
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBloodPressureRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBloodPressureRecord.kt
new file mode 100644
index 0000000..b0e3361
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBloodPressureRecord.kt
@@ -0,0 +1,102 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BloodPressureRecord
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.Pressure
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBloodPressureRecord : ReactHealthRecordImpl<BloodPressureRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BloodPressureRecord> {
+    return records.toMapList().map {
+      BloodPressureRecord(
+        time = Instant.parse(it.getString("time")),
+        systolic = getBloodPressureFromJsMap(it.getMap("systolic")),
+        diastolic = getBloodPressureFromJsMap(it.getMap("diastolic")),
+        bodyPosition = it.getSafeInt("bodyPosition", BloodPressureRecord.BODY_POSITION_UNKNOWN),
+        measurementLocation = it.getSafeInt(
+          "measurementLocation", BloodPressureRecord.MEASUREMENT_LOCATION_UNKNOWN
+        ),
+        zoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: BloodPressureRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("measurementLocation", record.measurementLocation)
+      putInt("bodyPosition", record.bodyPosition)
+      putMap("systolic", bloodPressureToJsMap(record.systolic))
+      putMap("diastolic", bloodPressureToJsMap(record.diastolic))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        BloodPressureRecord.SYSTOLIC_AVG,
+        BloodPressureRecord.SYSTOLIC_MIN,
+        BloodPressureRecord.SYSTOLIC_MAX,
+        BloodPressureRecord.DIASTOLIC_AVG,
+        BloodPressureRecord.DIASTOLIC_MIN,
+        BloodPressureRecord.DIASTOLIC_MAX
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+
+      putMap(
+        "SYSTOLIC_AVG",
+        getPressureMap(record[BloodPressureRecord.SYSTOLIC_AVG]?.inMillimetersOfMercury ?: 0.0)
+      )
+      putMap(
+        "SYSTOLIC_MIN",
+        getPressureMap(record[BloodPressureRecord.SYSTOLIC_MIN]?.inMillimetersOfMercury ?: 0.0)
+      )
+      putMap(
+        "DIASTOLIC_AVG",
+        getPressureMap(record[BloodPressureRecord.DIASTOLIC_AVG]?.inMillimetersOfMercury ?: 0.0)
+      )
+      putMap(
+        "DIASTOLIC_MIN",
+        getPressureMap(record[BloodPressureRecord.DIASTOLIC_MIN]?.inMillimetersOfMercury ?: 0.0)
+      )
+      putMap(
+        "DIASTOLIC_MAX",
+        getPressureMap(record[BloodPressureRecord.DIASTOLIC_MAX]?.inMillimetersOfMercury ?: 0.0)
+      )
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+
+  private fun bloodPressureToJsMap(pressure: Pressure): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("inMillimetersOfMercury", pressure.inMillimetersOfMercury)
+    }
+  }
+
+  private fun getBloodPressureFromJsMap(bloodPressureMap: ReadableMap?): Pressure {
+    if (bloodPressureMap == null) {
+      throw InvalidBloodPressure()
+    }
+
+    val value = bloodPressureMap.getDouble("value")
+    return Pressure.millimetersOfMercury(value)
+  }
+
+  private fun getPressureMap(inMillimetersOfMercury: Double): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("inMillimetersOfMercury", inMillimetersOfMercury)
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyFatRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyFatRecord.kt
new file mode 100644
index 0000000..f14edd8
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyFatRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BodyFatRecord
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.Percentage
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactBodyFatRecord : ReactHealthRecordImpl<BodyFatRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BodyFatRecord> {
+    return records.toMapList().map {
+      BodyFatRecord(
+        time = Instant.parse(it.getString("time")),
+        percentage = Percentage(it.getDouble("percentage")),
+        zoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: BodyFatRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putDouble("percentage", record.percentage.value)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyTemperatureRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyTemperatureRecord.kt
new file mode 100644
index 0000000..0b9147e
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyTemperatureRecord.kt
@@ -0,0 +1,65 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BodyTemperatureMeasurementLocation
+import androidx.health.connect.client.records.BodyTemperatureRecord
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.Temperature
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBodyTemperatureRecord : ReactHealthRecordImpl<BodyTemperatureRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BodyTemperatureRecord> {
+    return records.toMapList().map {
+      BodyTemperatureRecord(
+        time = Instant.parse(it.getString("time")),
+        zoneOffset = null,
+        temperature = getTemperatureFromJsMap(it.getMap("temperature")),
+        measurementLocation = it.getSafeInt(
+          "measurementLocation",
+          BodyTemperatureMeasurementLocation.MEASUREMENT_LOCATION_UNKNOWN
+        )
+      )
+    }
+  }
+
+  override fun parseRecord(record: BodyTemperatureRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("measurementLocation", record.measurementLocation)
+      putMap("temperature", temperatureToJsMap(record.temperature))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+
+  private fun getTemperatureFromJsMap(temperatureMap: ReadableMap?): Temperature {
+    if (temperatureMap == null) {
+      throw InvalidTemperature()
+    }
+
+    val value = temperatureMap.getDouble("value")
+    return when (temperatureMap.getString("unit")) {
+      "fahrenheit" -> Temperature.fahrenheit(value)
+      "celsius" -> Temperature.celsius(value)
+      else -> Temperature.celsius(value)
+    }
+  }
+
+  private fun temperatureToJsMap(temperature: Temperature): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("inFahrenheit", temperature.inFahrenheit)
+      putDouble("inCelsius", temperature.inCelsius)
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyWaterMassRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyWaterMassRecord.kt
new file mode 100644
index 0000000..e14b4e4
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBodyWaterMassRecord.kt
@@ -0,0 +1,38 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BodyWaterMassRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBodyWaterMassRecord : ReactHealthRecordImpl<BodyWaterMassRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BodyWaterMassRecord> {
+    return records.toMapList().map {
+      BodyWaterMassRecord(
+        time = Instant.parse(it.getString("time")),
+        mass = getMassFromJsMap(it.getMap("mass")),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: BodyWaterMassRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("mass", massToJsMap(record.mass))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBoneMassRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBoneMassRecord.kt
new file mode 100644
index 0000000..f5b0013
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactBoneMassRecord.kt
@@ -0,0 +1,38 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.BoneMassRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactBoneMassRecord : ReactHealthRecordImpl<BoneMassRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<BoneMassRecord> {
+    return records.toMapList().map {
+      BoneMassRecord(
+        time = Instant.parse(it.getString("time")),
+        mass = getMassFromJsMap(it.getMap("mass")),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: BoneMassRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("mass", massToJsMap(record.mass))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactCervicalMucusRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactCervicalMucusRecord.kt
new file mode 100644
index 0000000..c0d3bea
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactCervicalMucusRecord.kt
@@ -0,0 +1,43 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.CervicalMucusRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.getSafeInt
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactCervicalMucusRecord : ReactHealthRecordImpl<CervicalMucusRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<CervicalMucusRecord> {
+    return records.toMapList().map {
+      CervicalMucusRecord(
+        time = Instant.parse(it.getString("time")),
+        appearance = it.getSafeInt("appearance", CervicalMucusRecord.APPEARANCE_UNKNOWN),
+        sensation = it.getSafeInt("sensation", CervicalMucusRecord.SENSATION_UNKNOWN),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: CervicalMucusRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("appearance", record.appearance)
+      putInt("sensation", record.sensation)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactCyclingPedalingCadenceRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactCyclingPedalingCadenceRecord.kt
new file mode 100644
index 0000000..8e8cf3d
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactCyclingPedalingCadenceRecord.kt
@@ -0,0 +1,68 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.CyclingPedalingCadenceRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactCyclingPedalingCadenceRecord : ReactHealthRecordImpl<CyclingPedalingCadenceRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<CyclingPedalingCadenceRecord> {
+    return records.toMapList().map { map ->
+      CyclingPedalingCadenceRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        samples = map.getArray("samples")?.toMapList()?.map { sample ->
+          CyclingPedalingCadenceRecord.Sample(
+            time = Instant.parse(sample.getString("time")),
+            revolutionsPerMinute = sample.getDouble("revolutionsPerMinute")
+          )
+        } ?: emptyList(),
+        endZoneOffset = null,
+        startZoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: CyclingPedalingCadenceRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      val array = WritableNativeArray().apply {
+        record.samples.map {
+          val map = WritableNativeMap()
+          map.putString("time", it.time.toString())
+          map.putDouble("revolutionsPerMinute", it.revolutionsPerMinute)
+          this.pushMap(map)
+        }
+      }
+      putArray("samples", array)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        CyclingPedalingCadenceRecord.RPM_AVG,
+        CyclingPedalingCadenceRecord.RPM_MAX,
+        CyclingPedalingCadenceRecord.RPM_MIN
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("RPM_AVG", record[CyclingPedalingCadenceRecord.RPM_AVG] ?: 0.0)
+      putDouble("RPM_MAX", record[CyclingPedalingCadenceRecord.RPM_MAX] ?: 0.0)
+      putDouble("RPM_MIN", record[CyclingPedalingCadenceRecord.RPM_MIN] ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactDistanceRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactDistanceRecord.kt
new file mode 100644
index 0000000..2cafd77
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactDistanceRecord.kt
@@ -0,0 +1,51 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.DistanceRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactDistanceRecord : ReactHealthRecordImpl<DistanceRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<DistanceRecord> {
+    return records.toMapList().map { map ->
+      DistanceRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        distance = getLengthFromJsMap(map.getMap("distance")),
+        endZoneOffset = null,
+        startZoneOffset = null
+      )
+    }
+  }
+
+
+  override fun parseRecord(record: DistanceRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("distance", lengthToJsMap(record.distance))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        DistanceRecord.DISTANCE_TOTAL,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("DISTANCE", lengthToJsMap(record[DistanceRecord.DISTANCE_TOTAL]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactElevationGainedRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactElevationGainedRecord.kt
new file mode 100644
index 0000000..0151b20
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactElevationGainedRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.ElevationGainedRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactElevationGainedRecord : ReactHealthRecordImpl<ElevationGainedRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<ElevationGainedRecord> {
+    return records.toMapList().map {
+      ElevationGainedRecord(
+        startTime = Instant.parse(it.getString("startTime")),
+        endTime = Instant.parse(it.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        elevation = getLengthFromJsMap(it.getMap("elevation"))
+      )
+    }
+  }
+
+  override fun parseRecord(record: ElevationGainedRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("elevation", lengthToJsMap(record.elevation))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactExerciseSessionRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactExerciseSessionRecord.kt
new file mode 100644
index 0000000..266d55f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactExerciseSessionRecord.kt
@@ -0,0 +1,144 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.ExerciseLap
+import androidx.health.connect.client.records.ExerciseRoute
+import androidx.health.connect.client.records.ExerciseRouteResult
+import androidx.health.connect.client.records.ExerciseSegment
+import androidx.health.connect.client.records.ExerciseSessionRecord
+import androidx.health.connect.client.records.PowerRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactExerciseSessionRecord : ReactHealthRecordImpl<ExerciseSessionRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<ExerciseSessionRecord> {
+    return records.toMapList().map {
+      ExerciseSessionRecord(
+        startTime = Instant.parse(it.getString("startTime")),
+        endTime = Instant.parse(it.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        exerciseType = it.getSafeInt(
+          "exerciseType", ExerciseSessionRecord.EXERCISE_TYPE_OTHER_WORKOUT
+        ),
+        notes = it.getString("notes"),
+        title = it.getString("title"),
+        laps = it.getArray("samples")?.toMapList()?.map { sample ->
+          ExerciseLap(
+            startTime = Instant.parse(sample.getString("startTime")),
+            endTime = Instant.parse(sample.getString("endTime")),
+            length = getLengthFromJsMap(sample.getMap("length")),
+          )
+        } ?: emptyList(),
+        segments = it.getArray("samples")?.toMapList()?.map { sample ->
+          ExerciseSegment(
+            startTime = Instant.parse(sample.getString("startTime")),
+            endTime = Instant.parse(sample.getString("endTime")),
+            segmentType = sample.getSafeInt(
+              "segmentType", ExerciseSegment.EXERCISE_SEGMENT_TYPE_UNKNOWN
+            ),
+            repetitions = sample.getSafeInt("repetitions", 0),
+          )
+        } ?: emptyList(),
+        exerciseRoute = ExerciseRoute(
+          route = it.getMap("exerciseRoute")?.getArray("route")?.toMapList()?.map { sample ->
+            ExerciseRoute.Location(
+              time = Instant.parse(sample.getString("time")),
+              latitude = sample.getDouble("latitude"),
+              longitude = sample.getDouble("longitude"),
+              horizontalAccuracy = getLengthFromJsMap(sample.getMap("horizontalAccuracy")),
+              verticalAccuracy = getLengthFromJsMap(sample.getMap("verticalAccuracy")),
+              altitude = getLengthFromJsMap(sample.getMap("altitude")),
+            )
+          } ?: emptyList(),
+        )
+      )
+    }
+  }
+
+  override fun parseRecord(record: ExerciseSessionRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putString("notes", record.notes)
+      putString("title", record.title)
+      putInt("exerciseType", record.exerciseType)
+      putArray("laps", WritableNativeArray().apply {
+        record.laps.map {
+          val map = WritableNativeMap()
+          map.putString("startTime", it.startTime.toString())
+          map.putString("endTime", it.endTime.toString())
+          map.putMap("length", lengthToJsMap(it.length))
+          this.pushMap(map)
+        }
+      })
+      putArray("segments", WritableNativeArray().apply {
+        record.segments.map {
+          val map = WritableNativeMap()
+          map.putString("startTime", it.startTime.toString())
+          map.putString("endTime", it.endTime.toString())
+          map.putDouble("repetitions", it.repetitions.toDouble())
+          map.putDouble("segmentType", it.segmentType.toDouble())
+          this.pushMap(map)
+        }
+      })
+
+
+      when(record.exerciseRouteResult) {
+        is ExerciseRouteResult.Data -> {
+          val exerciseRouteMap = WritableNativeMap()
+          exerciseRouteMap.putArray("route", WritableNativeArray().apply {
+            (record.exerciseRouteResult as ExerciseRouteResult.Data).exerciseRoute.route.map {
+              val map = WritableNativeMap()
+              map.putString("time", it.time.toString())
+              map.putDouble("latitude", it.latitude)
+              map.putDouble("longitude", it.longitude)
+              map.putMap("horizontalAccuracy", lengthToJsMap(it.horizontalAccuracy))
+              map.putMap("verticalAccuracy", lengthToJsMap(it.verticalAccuracy))
+              map.putMap("altitude", lengthToJsMap(it.altitude))
+              this.pushMap(map)
+            }
+          })
+          putMap("exerciseRoute", exerciseRouteMap)
+        }
+        is ExerciseRouteResult.NoData -> {
+          putMap("exerciseRoute", WritableNativeMap())
+        }
+        is ExerciseRouteResult.ConsentRequired -> {
+          throw Exception("Consent required")
+        }
+        else -> {
+          putMap("exerciseRoute", WritableNativeMap())
+        }
+      }
+
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(ExerciseSessionRecord.EXERCISE_DURATION_TOTAL),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      val map = WritableNativeMap().apply {
+        putDouble(
+          "inSeconds",
+          record[ExerciseSessionRecord.EXERCISE_DURATION_TOTAL]?.seconds?.toDouble() ?: 0.0
+        )
+      }
+      putMap("EXERCISE_DURATION_TOTAL", map)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactFloorsClimbedRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactFloorsClimbedRecord.kt
new file mode 100644
index 0000000..0f665cf
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactFloorsClimbedRecord.kt
@@ -0,0 +1,48 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.FloorsClimbedRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactFloorsClimbedRecord : ReactHealthRecordImpl<FloorsClimbedRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<FloorsClimbedRecord> {
+    return records.toMapList().map {
+      FloorsClimbedRecord(
+        startTime = Instant.parse(it.getString("startTime")),
+        endTime = Instant.parse(it.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        floors = it.getDouble("floors")
+      )
+    }
+  }
+
+  override fun parseRecord(record: FloorsClimbedRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putDouble("floors", record.floors)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(FloorsClimbedRecord.FLOORS_CLIMBED_TOTAL),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("FLOORS_CLIMBED_TOTAL", record[FloorsClimbedRecord.FLOORS_CLIMBED_TOTAL] ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt
new file mode 100644
index 0000000..f0dfe2f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt
@@ -0,0 +1,90 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.Record
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.request.ReadRecordsRequest
+import androidx.health.connect.client.response.InsertRecordsResponse
+import androidx.health.connect.client.response.ReadRecordResponse
+import androidx.health.connect.client.response.ReadRecordsResponse
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.InvalidRecordType
+import dev.matinzd.healthconnect.utils.convertReactRequestOptionsFromJS
+import dev.matinzd.healthconnect.utils.reactRecordTypeToClassMap
+import dev.matinzd.healthconnect.utils.reactRecordTypeToReactClassMap
+import kotlin.reflect.KClass
+
+class ReactHealthRecord {
+  companion object {
+    private fun <T : Record> createReactHealthRecordInstance(recordType: String?): ReactHealthRecordImpl<T> {
+      if (!reactRecordTypeToReactClassMap.containsKey(recordType)) {
+        throw InvalidRecordType()
+      }
+
+      val reactClass = reactRecordTypeToReactClassMap[recordType]
+      return reactClass?.newInstance() as ReactHealthRecordImpl<T>
+    }
+
+    fun getRecordByType(recordType: String): KClass<out Record> {
+      if (!reactRecordTypeToClassMap.containsKey(recordType)) {
+        throw InvalidRecordType()
+      }
+
+      return reactRecordTypeToClassMap[recordType]!!
+    }
+
+    fun parseWriteRecords(reactRecords: ReadableArray): List<Record> {
+      val recordType = reactRecords.getMap(0)?.getString("recordType")
+
+      val recordClass = createReactHealthRecordInstance<Record>(recordType)
+
+      return recordClass.parseWriteRecord(reactRecords)
+    }
+
+    fun parseWriteResponse(response: InsertRecordsResponse?): WritableNativeArray {
+      val ids = WritableNativeArray()
+      response?.recordIdsList?.forEach { ids.pushString(it) }
+      return ids
+    }
+
+    fun parseReadRequest(recordType: String, reactRequest: ReadableMap): ReadRecordsRequest<*> {
+      return convertReactRequestOptionsFromJS(getRecordByType(recordType), reactRequest)
+    }
+
+    fun getAggregateRequest(recordType: String, reactRequest: ReadableMap): AggregateRequest {
+      val recordClass = createReactHealthRecordInstance<Record>(recordType)
+
+      return recordClass.getAggregateRequest(reactRequest)
+    }
+
+    fun parseAggregationResult(recordType: String, result: AggregationResult): WritableNativeMap {
+      val recordClass = createReactHealthRecordInstance<Record>(recordType)
+
+      return recordClass.parseAggregationResult(result)
+    }
+
+    fun parseRecords(
+      recordType: String,
+      response: ReadRecordsResponse<out Record>
+    ): WritableNativeArray {
+      val recordClass = createReactHealthRecordInstance<Record>(recordType)
+      return WritableNativeArray().apply {
+        for (record in response.records) {
+          pushMap(recordClass.parseRecord(record))
+        }
+      }
+    }
+
+    fun parseRecord(
+      recordType: String,
+      response: ReadRecordResponse<out Record>
+    ): WritableNativeMap {
+      val recordClass = createReactHealthRecordInstance<Record>(recordType)
+      return recordClass.parseRecord(response.record)
+    }
+  }
+}
+
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecordImpl.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecordImpl.kt
new file mode 100644
index 0000000..0ad3ae9
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecordImpl.kt
@@ -0,0 +1,15 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.Record
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+
+interface ReactHealthRecordImpl<T : Record> {
+  fun parseWriteRecord(records: ReadableArray): List<T>
+  fun parseRecord(record: T): WritableNativeMap
+  fun getAggregateRequest(record: ReadableMap): AggregateRequest
+  fun parseAggregationResult(record: AggregationResult): WritableNativeMap
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeartRateRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeartRateRecord.kt
new file mode 100644
index 0000000..7a06da7
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeartRateRecord.kt
@@ -0,0 +1,70 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.HeartRateRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactHeartRateRecord : ReactHealthRecordImpl<HeartRateRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<HeartRateRecord> {
+    return records.toMapList().map { map ->
+      HeartRateRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        samples = map.getArray("samples")?.toMapList()?.map { sample ->
+          HeartRateRecord.Sample(
+            time = Instant.parse(sample.getString("time")),
+            beatsPerMinute = sample.getDouble("beatsPerMinute").toLong()
+          )
+        } ?: emptyList(),
+      )
+    }
+  }
+
+  override fun parseRecord(record: HeartRateRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      val array = WritableNativeArray().apply {
+        record.samples.map {
+          val map = WritableNativeMap()
+          map.putString("time", it.time.toString())
+          map.putDouble("beatsPerMinute", it.beatsPerMinute.toDouble())
+          this.pushMap(map)
+        }
+      }
+      putArray("samples", array)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        HeartRateRecord.BPM_AVG,
+        HeartRateRecord.BPM_MAX,
+        HeartRateRecord.BPM_MIN,
+        HeartRateRecord.MEASUREMENTS_COUNT
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("BPM_AVG", record[HeartRateRecord.BPM_AVG]?.toDouble() ?: 0.0)
+      putDouble("BPM_MAX", record[HeartRateRecord.BPM_MAX]?.toDouble() ?: 0.0)
+      putDouble("BPM_MIN", record[HeartRateRecord.BPM_MIN]?.toDouble() ?: 0.0)
+      putDouble("MEASUREMENTS_COUNT", record[HeartRateRecord.MEASUREMENTS_COUNT]?.toDouble() ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeartRateVariabilityRmssdRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeartRateVariabilityRmssdRecord.kt
new file mode 100644
index 0000000..4b10d32
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeartRateVariabilityRmssdRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.HeartRateVariabilityRmssdRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactHeartRateVariabilityRmssdRecord :
+  ReactHealthRecordImpl<HeartRateVariabilityRmssdRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<HeartRateVariabilityRmssdRecord> {
+    return records.toMapList().map { map ->
+      HeartRateVariabilityRmssdRecord(
+        time = Instant.parse(map.getString("time")),
+        heartRateVariabilityMillis = map.getDouble("heartRateVariabilityMillis"),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: HeartRateVariabilityRmssdRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putDouble("heartRateVariabilityMillis", record.heartRateVariabilityMillis)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeightRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeightRecord.kt
new file mode 100644
index 0000000..a88cebb
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHeightRecord.kt
@@ -0,0 +1,51 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.HeightRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactHeightRecord : ReactHealthRecordImpl<HeightRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<HeightRecord> {
+    return records.toMapList().map { map ->
+      HeightRecord(
+        time = Instant.parse(map.getString("time")),
+        height = getLengthFromJsMap(map.getMap("height")),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: HeightRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("height", lengthToJsMap(record.height))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        HeightRecord.HEIGHT_AVG,
+        HeightRecord.HEIGHT_MAX,
+        HeightRecord.HEIGHT_MIN,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("HEIGHT_AVG", lengthToJsMap(record[HeightRecord.HEIGHT_AVG]))
+      putMap("HEIGHT_MIN", lengthToJsMap(record[HeightRecord.HEIGHT_MIN]))
+      putMap("HEIGHT_MAX", lengthToJsMap(record[HeightRecord.HEIGHT_MAX]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHydrationRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHydrationRecord.kt
new file mode 100644
index 0000000..21b39c7
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactHydrationRecord.kt
@@ -0,0 +1,50 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.HydrationRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactHydrationRecord : ReactHealthRecordImpl<HydrationRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<HydrationRecord> {
+    return records.toMapList().map { map ->
+      HydrationRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        volume = getVolumeFromJsMap(map.getMap("volume")),
+        endZoneOffset = null,
+        startZoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: HydrationRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("volume", volumeToJsMap(record.volume))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        HydrationRecord.VOLUME_TOTAL,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("VOLUME_TOTAL", volumeToJsMap(record[HydrationRecord.VOLUME_TOTAL]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactIntermenstrualBleedingRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactIntermenstrualBleedingRecord.kt
new file mode 100644
index 0000000..dd154c5
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactIntermenstrualBleedingRecord.kt
@@ -0,0 +1,38 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.IntermenstrualBleedingRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactIntermenstrualBleedingRecord : ReactHealthRecordImpl<IntermenstrualBleedingRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<IntermenstrualBleedingRecord> {
+    return records.toMapList().map { map ->
+      IntermenstrualBleedingRecord(
+        time = Instant.parse(map.getString("time")),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: IntermenstrualBleedingRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactLeanBodyMassRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactLeanBodyMassRecord.kt
new file mode 100644
index 0000000..ee2f680
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactLeanBodyMassRecord.kt
@@ -0,0 +1,38 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.LeanBodyMassRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactLeanBodyMassRecord : ReactHealthRecordImpl<LeanBodyMassRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<LeanBodyMassRecord> {
+    return records.toMapList().map { map ->
+      LeanBodyMassRecord(
+        time = Instant.parse(map.getString("time")),
+        mass = getMassFromJsMap(map.getMap("mass")),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: LeanBodyMassRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("mass", massToJsMap(record.mass))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactMenstruationFlowRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactMenstruationFlowRecord.kt
new file mode 100644
index 0000000..2ae068c
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactMenstruationFlowRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.MenstruationFlowRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.getSafeInt
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactMenstruationFlowRecord : ReactHealthRecordImpl<MenstruationFlowRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<MenstruationFlowRecord> {
+    return records.toMapList().map { map ->
+      MenstruationFlowRecord(
+        time = Instant.parse(map.getString("time")),
+        flow = map.getSafeInt("flow", MenstruationFlowRecord.FLOW_UNKNOWN),
+        zoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: MenstruationFlowRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("flow", record.flow)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactMenstruationPeriodRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactMenstruationPeriodRecord.kt
new file mode 100644
index 0000000..df7a76d
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactMenstruationPeriodRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.MenstruationPeriodRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactMenstruationPeriodRecord : ReactHealthRecordImpl<MenstruationPeriodRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<MenstruationPeriodRecord> {
+    return records.toMapList().map { map ->
+      MenstruationPeriodRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        endZoneOffset = null,
+        startZoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: MenstruationPeriodRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactNutritionRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactNutritionRecord.kt
new file mode 100644
index 0000000..7567c0c
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactNutritionRecord.kt
@@ -0,0 +1,223 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.MealType
+import androidx.health.connect.client.records.NutritionRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactNutritionRecord : ReactHealthRecordImpl<NutritionRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<NutritionRecord> {
+    return records.toMapList().map { map ->
+      NutritionRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        biotin = getMassFromJsMap(map.getMap("biotin")),
+        caffeine = getMassFromJsMap(map.getMap("caffeine")),
+        calcium = getMassFromJsMap(map.getMap("calcium")),
+        energy = getEnergyFromJsMap(map.getMap("energy")),
+        energyFromFat = getEnergyFromJsMap(map.getMap("energyFromFat")),
+        chloride = getMassFromJsMap(map.getMap("chloride")),
+        cholesterol = getMassFromJsMap(map.getMap("cholesterol")),
+        chromium = getMassFromJsMap(map.getMap("chromium")),
+        copper = getMassFromJsMap(map.getMap("copper")),
+        dietaryFiber = getMassFromJsMap(map.getMap("dietaryFiber")),
+        folate = getMassFromJsMap(map.getMap("folate")),
+        folicAcid = getMassFromJsMap(map.getMap("folicAcid")),
+        iodine = getMassFromJsMap(map.getMap("iodine")),
+        iron = getMassFromJsMap(map.getMap("iron")),
+        magnesium = getMassFromJsMap(map.getMap("magnesium")),
+        manganese = getMassFromJsMap(map.getMap("manganese")),
+        molybdenum = getMassFromJsMap(map.getMap("molybdenum")),
+        monounsaturatedFat = getMassFromJsMap(map.getMap("monounsaturatedFat")),
+        niacin = getMassFromJsMap(map.getMap("niacin")),
+        pantothenicAcid = getMassFromJsMap(map.getMap("pantothenicAcid")),
+        phosphorus = getMassFromJsMap(map.getMap("phosphorus")),
+        polyunsaturatedFat = getMassFromJsMap(map.getMap("polyunsaturatedFat")),
+        potassium = getMassFromJsMap(map.getMap("potassium")),
+        protein = getMassFromJsMap(map.getMap("protein")),
+        riboflavin = getMassFromJsMap(map.getMap("riboflavin")),
+        saturatedFat = getMassFromJsMap(map.getMap("saturatedFat")),
+        selenium = getMassFromJsMap(map.getMap("selenium")),
+        sodium = getMassFromJsMap(map.getMap("sodium")),
+        sugar = getMassFromJsMap(map.getMap("sugar")),
+        thiamin = getMassFromJsMap(map.getMap("thiamin")),
+        totalCarbohydrate = getMassFromJsMap(map.getMap("totalCarbohydrate")),
+        totalFat = getMassFromJsMap(map.getMap("totalFat")),
+        transFat = getMassFromJsMap(map.getMap("transFat")),
+        unsaturatedFat = getMassFromJsMap(map.getMap("unsaturatedFat")),
+        vitaminA = getMassFromJsMap(map.getMap("vitaminA")),
+        vitaminB12 = getMassFromJsMap(map.getMap("vitaminB12")),
+        vitaminB6 = getMassFromJsMap(map.getMap("vitaminB6")),
+        vitaminC = getMassFromJsMap(map.getMap("vitaminC")),
+        vitaminD = getMassFromJsMap(map.getMap("vitaminD")),
+        vitaminE = getMassFromJsMap(map.getMap("vitaminE")),
+        vitaminK = getMassFromJsMap(map.getMap("vitaminK")),
+        zinc = getMassFromJsMap(map.getMap("zinc")),
+        name = map.getString("name"),
+        mealType = map.getSafeInt("mealType", MealType.MEAL_TYPE_UNKNOWN),
+      )
+    }
+  }
+
+  override fun parseRecord(record: NutritionRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("biotin", massToJsMap(record.biotin))
+      putMap("caffeine", massToJsMap(record.caffeine))
+      putMap("calcium", massToJsMap(record.calcium))
+      putMap("energy", energyToJsMap(record.energy))
+      putMap("energyFromFat", energyToJsMap(record.energyFromFat))
+      putMap("chloride", massToJsMap(record.chloride))
+      putMap("cholesterol", massToJsMap(record.cholesterol))
+      putMap("chromium", massToJsMap(record.chromium))
+      putMap("copper", massToJsMap(record.copper))
+      putMap("dietaryFiber", massToJsMap(record.dietaryFiber))
+      putMap("folate", massToJsMap(record.folate))
+      putMap("folicAcid", massToJsMap(record.folicAcid))
+      putMap("iodine", massToJsMap(record.iodine))
+      putMap("iron", massToJsMap(record.iron))
+      putMap("magnesium", massToJsMap(record.magnesium))
+      putMap("manganese", massToJsMap(record.manganese))
+      putMap("molybdenum", massToJsMap(record.molybdenum))
+      putMap("monounsaturatedFat", massToJsMap(record.monounsaturatedFat))
+      putMap("niacin", massToJsMap(record.niacin))
+      putMap("pantothenicAcid", massToJsMap(record.pantothenicAcid))
+      putMap("phosphorus", massToJsMap(record.phosphorus))
+      putMap("polyunsaturatedFat", massToJsMap(record.polyunsaturatedFat))
+      putMap("potassium", massToJsMap(record.potassium))
+      putMap("protein", massToJsMap(record.protein))
+      putMap("riboflavin", massToJsMap(record.riboflavin))
+      putMap("saturatedFat", massToJsMap(record.saturatedFat))
+      putMap("selenium", massToJsMap(record.selenium))
+      putMap("sodium", massToJsMap(record.sodium))
+      putMap("sugar", massToJsMap(record.sugar))
+      putMap("thiamin", massToJsMap(record.thiamin))
+      putMap("totalCarbohydrate", massToJsMap(record.totalCarbohydrate))
+      putMap("totalFat", massToJsMap(record.totalFat))
+      putMap("transFat", massToJsMap(record.transFat))
+      putMap("unsaturatedFat", massToJsMap(record.unsaturatedFat))
+      putMap("vitaminA", massToJsMap(record.vitaminA))
+      putMap("vitaminB12", massToJsMap(record.vitaminB12))
+      putMap("vitaminB6", massToJsMap(record.vitaminB6))
+      putMap("vitaminC", massToJsMap(record.vitaminC))
+      putMap("vitaminD", massToJsMap(record.vitaminD))
+      putMap("vitaminE", massToJsMap(record.vitaminE))
+      putMap("vitaminK", massToJsMap(record.vitaminK))
+      putMap("zinc", massToJsMap(record.zinc))
+      putString("name", record.name)
+      putInt("mealType", record.mealType)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        NutritionRecord.BIOTIN_TOTAL,
+        NutritionRecord.CAFFEINE_TOTAL,
+        NutritionRecord.CALCIUM_TOTAL,
+        NutritionRecord.ENERGY_TOTAL,
+        NutritionRecord.ENERGY_FROM_FAT_TOTAL,
+        NutritionRecord.CHLORIDE_TOTAL,
+        NutritionRecord.CHOLESTEROL_TOTAL,
+        NutritionRecord.CHROMIUM_TOTAL,
+        NutritionRecord.COPPER_TOTAL,
+        NutritionRecord.DIETARY_FIBER_TOTAL,
+        NutritionRecord.FOLATE_TOTAL,
+        NutritionRecord.FOLIC_ACID_TOTAL,
+        NutritionRecord.IODINE_TOTAL,
+        NutritionRecord.IRON_TOTAL,
+        NutritionRecord.MAGNESIUM_TOTAL,
+        NutritionRecord.MANGANESE_TOTAL,
+        NutritionRecord.MOLYBDENUM_TOTAL,
+        NutritionRecord.MONOUNSATURATED_FAT_TOTAL,
+        NutritionRecord.NIACIN_TOTAL,
+        NutritionRecord.PANTOTHENIC_ACID_TOTAL,
+        NutritionRecord.PHOSPHORUS_TOTAL,
+        NutritionRecord.POLYUNSATURATED_FAT_TOTAL,
+        NutritionRecord.POTASSIUM_TOTAL,
+        NutritionRecord.PROTEIN_TOTAL,
+        NutritionRecord.RIBOFLAVIN_TOTAL,
+        NutritionRecord.SATURATED_FAT_TOTAL,
+        NutritionRecord.SELENIUM_TOTAL,
+        NutritionRecord.SODIUM_TOTAL,
+        NutritionRecord.SUGAR_TOTAL,
+        NutritionRecord.THIAMIN_TOTAL,
+        NutritionRecord.TOTAL_CARBOHYDRATE_TOTAL,
+        NutritionRecord.TOTAL_FAT_TOTAL,
+        NutritionRecord.ZINC_TOTAL,
+        NutritionRecord.VITAMIN_A_TOTAL,
+        NutritionRecord.VITAMIN_B12_TOTAL,
+        NutritionRecord.VITAMIN_B6_TOTAL,
+        NutritionRecord.VITAMIN_C_TOTAL,
+        NutritionRecord.VITAMIN_D_TOTAL,
+        NutritionRecord.VITAMIN_E_TOTAL,
+        NutritionRecord.VITAMIN_K_TOTAL,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("BIOTIN_TOTAL", massToJsMap(record[NutritionRecord.BIOTIN_TOTAL]))
+      putMap("CAFFEINE_TOTAL", massToJsMap(record[NutritionRecord.CAFFEINE_TOTAL]))
+      putMap("CALCIUM_TOTAL", massToJsMap(record[NutritionRecord.CALCIUM_TOTAL]))
+      putMap("ENERGY_TOTAL", energyToJsMap(record[NutritionRecord.ENERGY_TOTAL]))
+      putMap(
+        "ENERGY_FROM_FAT_TOTAL", energyToJsMap(record[NutritionRecord.ENERGY_FROM_FAT_TOTAL])
+      )
+      putMap("CHLORIDE_TOTAL", massToJsMap(record[NutritionRecord.CHLORIDE_TOTAL]))
+      putMap("CHOLESTEROL_TOTAL", massToJsMap(record[NutritionRecord.CHOLESTEROL_TOTAL]))
+      putMap("CHROMIUM_TOTAL", massToJsMap(record[NutritionRecord.CHROMIUM_TOTAL]))
+      putMap("COPPER_TOTAL", massToJsMap(record[NutritionRecord.COPPER_TOTAL]))
+      putMap("DIETARY_FIBER_TOTAL", massToJsMap(record[NutritionRecord.DIETARY_FIBER_TOTAL]))
+      putMap("FOLATE_TOTAL", massToJsMap(record[NutritionRecord.FOLATE_TOTAL]))
+      putMap("FOLIC_ACID_TOTAL", massToJsMap(record[NutritionRecord.FOLIC_ACID_TOTAL]))
+      putMap("IODINE_TOTAL", massToJsMap(record[NutritionRecord.IODINE_TOTAL]))
+      putMap("IRON_TOTAL", massToJsMap(record[NutritionRecord.IRON_TOTAL]))
+      putMap("MAGNESIUM_TOTAL", massToJsMap(record[NutritionRecord.MAGNESIUM_TOTAL]))
+      putMap("MANGANESE_TOTAL", massToJsMap(record[NutritionRecord.MANGANESE_TOTAL]))
+      putMap("MOLYBDENUM_TOTAL", massToJsMap(record[NutritionRecord.MOLYBDENUM_TOTAL]))
+      putMap(
+        "MONOUNSATURATED_FAT_TOTAL", massToJsMap(record[NutritionRecord.MONOUNSATURATED_FAT_TOTAL])
+      )
+      putMap("NIACIN_TOTAL", massToJsMap(record[NutritionRecord.NIACIN_TOTAL]))
+      putMap("PANTOTHENIC_ACID_TOTAL", massToJsMap(record[NutritionRecord.PANTOTHENIC_ACID_TOTAL]))
+      putMap("PHOSPHORUS_TOTAL", massToJsMap(record[NutritionRecord.PHOSPHORUS_TOTAL]))
+      putMap(
+        "POLYUNSATURATED_FAT_TOTAL", massToJsMap(record[NutritionRecord.POLYUNSATURATED_FAT_TOTAL])
+      )
+      putMap("POTASSIUM_TOTAL", massToJsMap(record[NutritionRecord.POTASSIUM_TOTAL]))
+      putMap("PROTEIN_TOTAL", massToJsMap(record[NutritionRecord.PROTEIN_TOTAL]))
+      putMap("RIBOFLAVIN_TOTAL", massToJsMap(record[NutritionRecord.RIBOFLAVIN_TOTAL]))
+      putMap("SATURATED_FAT_TOTAL", massToJsMap(record[NutritionRecord.SATURATED_FAT_TOTAL]))
+      putMap("SELENIUM_TOTAL", massToJsMap(record[NutritionRecord.SELENIUM_TOTAL]))
+      putMap("SODIUM_TOTAL", massToJsMap(record[NutritionRecord.SODIUM_TOTAL]))
+      putMap("SUGAR_TOTAL", massToJsMap(record[NutritionRecord.SUGAR_TOTAL]))
+      putMap("THIAMIN_TOTAL", massToJsMap(record[NutritionRecord.THIAMIN_TOTAL]))
+      putMap(
+        "TOTAL_CARBOHYDRATE_TOTAL", massToJsMap(record[NutritionRecord.TOTAL_CARBOHYDRATE_TOTAL])
+      )
+      putMap("TOTAL_FAT_TOTAL", massToJsMap(record[NutritionRecord.TOTAL_FAT_TOTAL]))
+      putMap("ZINC_TOTAL", massToJsMap(record[NutritionRecord.ZINC_TOTAL]))
+      putMap("VITAMIN_A_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_A_TOTAL]))
+      putMap("VITAMIN_B12_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_B12_TOTAL]))
+      putMap("VITAMIN_B6_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_B6_TOTAL]))
+      putMap("VITAMIN_C_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_C_TOTAL]))
+      putMap("VITAMIN_D_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_D_TOTAL]))
+      putMap("VITAMIN_E_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_E_TOTAL]))
+      putMap("VITAMIN_K_TOTAL", massToJsMap(record[NutritionRecord.VITAMIN_K_TOTAL]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactOvulationTestRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactOvulationTestRecord.kt
new file mode 100644
index 0000000..620a2d5
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactOvulationTestRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.OvulationTestRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.getSafeInt
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactOvulationTestRecord : ReactHealthRecordImpl<OvulationTestRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<OvulationTestRecord> {
+    return records.toMapList().map { map ->
+      OvulationTestRecord(
+        time = Instant.parse(map.getString("time")), zoneOffset = null, result = map.getSafeInt(
+          "result", OvulationTestRecord.RESULT_INCONCLUSIVE
+        )
+      )
+    }
+  }
+
+  override fun parseRecord(record: OvulationTestRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("result", record.result)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactOxygenSaturationRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactOxygenSaturationRecord.kt
new file mode 100644
index 0000000..e071397
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactOxygenSaturationRecord.kt
@@ -0,0 +1,41 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.OxygenSaturationRecord
+import androidx.health.connect.client.request.AggregateRequest
+import androidx.health.connect.client.units.Percentage
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactOxygenSaturationRecord : ReactHealthRecordImpl<OxygenSaturationRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<OxygenSaturationRecord> {
+    return records.toMapList().map { map ->
+      OxygenSaturationRecord(
+        time = Instant.parse(map.getString("time")),
+        zoneOffset = null,
+        percentage = Percentage(map.getDouble("percentage")),
+      )
+    }
+  }
+
+  override fun parseRecord(record: OxygenSaturationRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putDouble("percentage", record.percentage.value)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactPowerRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactPowerRecord.kt
new file mode 100644
index 0000000..0e742f1
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactPowerRecord.kt
@@ -0,0 +1,68 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.PowerRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactPowerRecord : ReactHealthRecordImpl<PowerRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<PowerRecord> {
+    return records.toMapList().map { map ->
+      PowerRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        samples = map.getArray("samples")?.toMapList()?.map { sample ->
+          PowerRecord.Sample(
+            time = Instant.parse(sample.getString("time")),
+            power = getPowerFromJsMap(sample.getMap("power"))
+          )
+        } ?: emptyList(),
+      )
+    }
+  }
+
+  override fun parseRecord(record: PowerRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      val array = WritableNativeArray().apply {
+        record.samples.map {
+          val map = WritableNativeMap()
+          map.putString("time", it.time.toString())
+          map.putMap("power", powerToJsMap(it.power))
+          this.pushMap(map)
+        }
+      }
+      putArray("samples", array)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        PowerRecord.POWER_AVG,
+        PowerRecord.POWER_MAX,
+        PowerRecord.POWER_MIN,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("POWER_AVG", powerToJsMap(record[PowerRecord.POWER_AVG]))
+      putMap("POWER_MAX", powerToJsMap(record[PowerRecord.POWER_MAX]))
+      putMap("POWER_MIN", powerToJsMap(record[PowerRecord.POWER_MIN]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactRespiratoryRateRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactRespiratoryRateRecord.kt
new file mode 100644
index 0000000..3d97845
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactRespiratoryRateRecord.kt
@@ -0,0 +1,38 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.RespiratoryRateRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactRespiratoryRateRecord : ReactHealthRecordImpl<RespiratoryRateRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<RespiratoryRateRecord> {
+    return records.toMapList().map { map ->
+      RespiratoryRateRecord(
+        time = Instant.parse(map.getString("time")), zoneOffset = null, rate = map.getDouble("rate")
+      )
+    }
+  }
+
+  override fun parseRecord(record: RespiratoryRateRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putDouble("rate", record.rate)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactRestingHeartRateRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactRestingHeartRateRecord.kt
new file mode 100644
index 0000000..0797ec1
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactRestingHeartRateRecord.kt
@@ -0,0 +1,51 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.RestingHeartRateRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactRestingHeartRateRecord : ReactHealthRecordImpl<RestingHeartRateRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<RestingHeartRateRecord> {
+    return records.toMapList().map { map ->
+      RestingHeartRateRecord(
+        time = Instant.parse(map.getString("time")),
+        zoneOffset = null,
+        beatsPerMinute = map.getDouble("beatsPerMinute").toLong()
+      )
+    }
+  }
+
+  override fun parseRecord(record: RestingHeartRateRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putDouble("beatsPerMinute", record.beatsPerMinute.toDouble())
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        RestingHeartRateRecord.BPM_AVG,
+        RestingHeartRateRecord.BPM_MAX,
+        RestingHeartRateRecord.BPM_MIN,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("BPM_AVG", record[RestingHeartRateRecord.BPM_AVG]?.toDouble() ?: 0.0)
+      putDouble("BPM_MAX", record[RestingHeartRateRecord.BPM_MAX]?.toDouble() ?: 0.0)
+      putDouble("BPM_MIN", record[RestingHeartRateRecord.BPM_MIN]?.toDouble() ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSexualActivityRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSexualActivityRecord.kt
new file mode 100644
index 0000000..ea901f7
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSexualActivityRecord.kt
@@ -0,0 +1,40 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.SexualActivityRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactSexualActivityRecord : ReactHealthRecordImpl<SexualActivityRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<SexualActivityRecord> {
+    return records.toMapList().map { map ->
+      SexualActivityRecord(
+        time = Instant.parse(map.getString("time")),
+        protectionUsed = map.getInt("protectionUsed"),
+        zoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: SexualActivityRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putInt("protectionUsed", record.protectionUsed)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSleepSessionRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSleepSessionRecord.kt
new file mode 100644
index 0000000..8d0dfb0
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSleepSessionRecord.kt
@@ -0,0 +1,72 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.SleepSessionRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactSleepSessionRecord : ReactHealthRecordImpl<SleepSessionRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<SleepSessionRecord> {
+    return records.toMapList().map { map ->
+      SleepSessionRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        stages = map.getArray("stages")?.toMapList()?.map { stageMap ->
+          SleepSessionRecord.Stage(
+            startTime = Instant.parse(stageMap.getString("startTime")),
+            endTime = Instant.parse(stageMap.getString("endTime")),
+            stage = stageMap.getSafeInt("stage", SleepSessionRecord.STAGE_TYPE_UNKNOWN),
+          )
+        } ?: emptyList(),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        title = map.getString("title"),
+        notes = map.getString("description"),
+      )
+    }
+  }
+
+  override fun parseRecord(record: SleepSessionRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putString("title", record.title)
+      putString("notes", record.notes)
+      putArray("stages", WritableNativeArray().apply {
+        record.stages.map {
+          val map = WritableNativeMap()
+          map.putString("startTime", it.startTime.toString())
+          map.putString("endTime", it.endTime.toString())
+          map.putDouble("stage", it.stage.toDouble())
+          this.pushMap(map)
+        }
+      })
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        SleepSessionRecord.SLEEP_DURATION_TOTAL
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble(
+        "SLEEP_DURATION_TOTAL",
+        record[SleepSessionRecord.SLEEP_DURATION_TOTAL]?.seconds?.toDouble() ?: 0.0
+      )
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSpeedRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSpeedRecord.kt
new file mode 100644
index 0000000..51028a5
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactSpeedRecord.kt
@@ -0,0 +1,68 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.SpeedRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactSpeedRecord : ReactHealthRecordImpl<SpeedRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<SpeedRecord> {
+    return records.toMapList().map { map ->
+      SpeedRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        samples = map.getArray("samples")?.toMapList()?.map { sample ->
+          SpeedRecord.Sample(
+            time = Instant.parse(sample.getString("time")),
+            speed = getVelocityFromJsMap(sample.getMap("speed"))
+          )
+        } ?: emptyList(),
+      )
+    }
+  }
+
+  override fun parseRecord(record: SpeedRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      val array = WritableNativeArray().apply {
+        record.samples.map {
+          val map = WritableNativeMap()
+          map.putString("time", it.time.toString())
+          map.putMap("speed", velocityToJsMap(it.speed))
+          this.pushMap(map)
+        }
+      }
+      putArray("samples", array)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        SpeedRecord.SPEED_AVG,
+        SpeedRecord.SPEED_MIN,
+        SpeedRecord.SPEED_MAX,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("SPEED_AVG", velocityToJsMap(record[SpeedRecord.SPEED_AVG]))
+      putMap("SPEED_MAX", velocityToJsMap(record[SpeedRecord.SPEED_MAX]))
+      putMap("SPEED_MIN", velocityToJsMap(record[SpeedRecord.SPEED_MIN]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactStepsCadenceRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactStepsCadenceRecord.kt
new file mode 100644
index 0000000..4bc9705
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactStepsCadenceRecord.kt
@@ -0,0 +1,68 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.StepsCadenceRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactStepsCadenceRecord : ReactHealthRecordImpl<StepsCadenceRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<StepsCadenceRecord> {
+    return records.toMapList().map { map ->
+      StepsCadenceRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        samples = map.getArray("samples")?.toMapList()?.map { sample ->
+          StepsCadenceRecord.Sample(
+            time = Instant.parse(sample.getString("time")),
+            rate = sample.getDouble("count")
+          )
+        } ?: emptyList()
+      )
+    }
+  }
+
+  override fun parseRecord(record: StepsCadenceRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      val array = WritableNativeArray().apply {
+        record.samples.map {
+          val map = WritableNativeMap()
+          map.putString("time", it.time.toString())
+          map.putDouble("rate", it.rate)
+          this.pushMap(map)
+        }
+      }
+      putArray("samples", array)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        StepsCadenceRecord.RATE_AVG,
+        StepsCadenceRecord.RATE_MAX,
+        StepsCadenceRecord.RATE_MIN,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("RATE_AVG", record[StepsCadenceRecord.RATE_AVG]?.toDouble() ?: 0.0)
+      putDouble("RATE_MAX", record[StepsCadenceRecord.RATE_MAX]?.toDouble() ?: 0.0)
+      putDouble("RATE_MIN", record[StepsCadenceRecord.RATE_MIN]?.toDouble() ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactStepsRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactStepsRecord.kt
new file mode 100644
index 0000000..98f0701
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactStepsRecord.kt
@@ -0,0 +1,50 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.StepsRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactStepsRecord : ReactHealthRecordImpl<StepsRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<StepsRecord> {
+    return records.toMapList().map { map ->
+      StepsRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        count = map.getDouble("count").toLong()
+      )
+    }
+  }
+
+  override fun parseRecord(record: StepsRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putDouble("count", record.count.toDouble())
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        StepsRecord.COUNT_TOTAL
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("COUNT_TOTAL", record[StepsRecord.COUNT_TOTAL]?.toDouble() ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactTotalCaloriesBurnedRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactTotalCaloriesBurnedRecord.kt
new file mode 100644
index 0000000..708f964
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactTotalCaloriesBurnedRecord.kt
@@ -0,0 +1,68 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.TotalCaloriesBurnedRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactTotalCaloriesBurnedRecord : ReactHealthRecordImpl<TotalCaloriesBurnedRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<TotalCaloriesBurnedRecord> {
+    return records.toMapList().map { map ->
+      TotalCaloriesBurnedRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        startZoneOffset = null,
+        endZoneOffset = null,
+        energy = getEnergyFromJsMap(map.getMap("energy"))
+      )
+    }
+  }
+
+  override fun parseRecord(record: TotalCaloriesBurnedRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putMap("energy", energyToJsMap(record.energy))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        TotalCaloriesBurnedRecord.ENERGY_TOTAL
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      val map = WritableNativeMap().apply {
+        putDouble(
+          "inCalories",
+          record[TotalCaloriesBurnedRecord.ENERGY_TOTAL]?.inCalories ?: 0.0
+        )
+        putDouble(
+          "inKilojoules",
+          record[TotalCaloriesBurnedRecord.ENERGY_TOTAL]?.inKilojoules ?: 0.0
+        )
+        putDouble(
+          "inKilocalories",
+          record[TotalCaloriesBurnedRecord.ENERGY_TOTAL]?.inKilocalories ?: 0.0
+        )
+        putDouble(
+          "inJoules",
+          record[TotalCaloriesBurnedRecord.ENERGY_TOTAL]?.inJoules ?: 0.0
+        )
+      }
+      putMap("ENERGY_TOTAL", map)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactVo2MaxRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactVo2MaxRecord.kt
new file mode 100644
index 0000000..1fa3b52
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactVo2MaxRecord.kt
@@ -0,0 +1,46 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.Vo2MaxRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.AggregationNotSupported
+import dev.matinzd.healthconnect.utils.convertMetadataToJSMap
+import dev.matinzd.healthconnect.utils.getSafeInt
+import dev.matinzd.healthconnect.utils.toMapList
+import java.time.Instant
+
+class ReactVo2MaxRecord : ReactHealthRecordImpl<Vo2MaxRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<Vo2MaxRecord> {
+    return records.toMapList().map { map ->
+      Vo2MaxRecord(
+        time = Instant.parse(map.getString("time")),
+        zoneOffset = null,
+        vo2MillilitersPerMinuteKilogram = map.getDouble("vo2Max"),
+        measurementMethod = map.getSafeInt(
+          "measurementMethod",
+          Vo2MaxRecord.MEASUREMENT_METHOD_OTHER
+        ),
+      )
+    }
+  }
+
+  override fun parseRecord(record: Vo2MaxRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putDouble("vo2MillilitersPerMinuteKilogram", record.vo2MillilitersPerMinuteKilogram)
+      putInt("measurementMethod", record.measurementMethod)
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    throw AggregationNotSupported()
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    throw AggregationNotSupported()
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactWeightRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactWeightRecord.kt
new file mode 100644
index 0000000..e366d85
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactWeightRecord.kt
@@ -0,0 +1,51 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.WeightRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactWeightRecord : ReactHealthRecordImpl<WeightRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<WeightRecord> {
+    return records.toMapList().map { map ->
+      WeightRecord(
+        time = Instant.parse(map.getString("time")),
+        weight = getMassFromJsMap(map.getMap("weight")),
+        zoneOffset = null
+      )
+    }
+  }
+
+  override fun parseRecord(record: WeightRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("time", record.time.toString())
+      putMap("weight", massToJsMap(record.weight))
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        WeightRecord.WEIGHT_AVG,
+        WeightRecord.WEIGHT_MAX,
+        WeightRecord.WEIGHT_MIN,
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putMap("WEIGHT_AVG", massToJsMap(record[WeightRecord.WEIGHT_AVG]))
+      putMap("WEIGHT_MAX", massToJsMap(record[WeightRecord.WEIGHT_MAX]))
+      putMap("WEIGHT_MIN", massToJsMap(record[WeightRecord.WEIGHT_MIN]))
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactWheelchairPushesRecord.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactWheelchairPushesRecord.kt
new file mode 100644
index 0000000..c7981de
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/records/ReactWheelchairPushesRecord.kt
@@ -0,0 +1,50 @@
+package dev.matinzd.healthconnect.records
+
+import androidx.health.connect.client.aggregate.AggregationResult
+import androidx.health.connect.client.records.WheelchairPushesRecord
+import androidx.health.connect.client.request.AggregateRequest
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.utils.*
+import java.time.Instant
+
+class ReactWheelchairPushesRecord : ReactHealthRecordImpl<WheelchairPushesRecord> {
+  override fun parseWriteRecord(records: ReadableArray): List<WheelchairPushesRecord> {
+    return records.toMapList().map { map ->
+      WheelchairPushesRecord(
+        startTime = Instant.parse(map.getString("startTime")),
+        endTime = Instant.parse(map.getString("endTime")),
+        count = map.getDouble("count").toLong(),
+        startZoneOffset = null,
+        endZoneOffset = null,
+      )
+    }
+  }
+
+  override fun parseRecord(record: WheelchairPushesRecord): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putString("startTime", record.startTime.toString())
+      putString("endTime", record.endTime.toString())
+      putDouble("count", record.count.toDouble())
+      putMap("metadata", convertMetadataToJSMap(record.metadata))
+    }
+  }
+
+  override fun getAggregateRequest(record: ReadableMap): AggregateRequest {
+    return AggregateRequest(
+      metrics = setOf(
+        WheelchairPushesRecord.COUNT_TOTAL
+      ),
+      timeRangeFilter = record.getTimeRangeFilter("timeRangeFilter"),
+      dataOriginFilter = convertJsToDataOriginSet(record.getArray("dataOriginFilter"))
+    )
+  }
+
+  override fun parseAggregationResult(record: AggregationResult): WritableNativeMap {
+    return WritableNativeMap().apply {
+      putDouble("COUNT_TOTAL", record[WheelchairPushesRecord.COUNT_TOTAL]?.toDouble() ?: 0.0)
+      putArray("dataOrigins", convertDataOriginsToJsArray(record.dataOrigins))
+    }
+  }
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/utils/ExceptionsUtils.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/utils/ExceptionsUtils.kt
new file mode 100644
index 0000000..8b860c9
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/utils/ExceptionsUtils.kt
@@ -0,0 +1,40 @@
+package dev.matinzd.healthconnect.utils
+
+import android.os.RemoteException
+import com.facebook.react.bridge.Promise
+import okio.IOException
+
+class ClientNotInitialized : Exception("Health Connect client is not initialized")
+class InvalidRecordType : Exception("Record type is not valid")
+class InvalidTemperature : Exception("Temperature is not valid")
+class InvalidEnergy : Exception("Energy is not valid")
+class InvalidVelocity : Exception("Velocity is not valid")
+class InvalidPower : Exception("Power is not valid")
+class InvalidBloodGlucoseLevel : Exception("Blood glucose level is not valid")
+class InvalidBloodPressure : Exception("Blood pressure is not valid")
+class InvalidMass : Exception("Mass is not valid")
+class InvalidLength : Exception("Length is not valid")
+class AggregationNotSupported : Exception("Aggregation is not supported for this record")
+
+fun Promise.rejectWithException(exception: Exception) {
+  val code = when (exception) {
+    is SecurityException -> "PERMISSION_ERROR"
+    is UnsupportedOperationException -> "SDK_VERSION_ERROR"
+    is IOException -> "IO_EXCEPTION"
+    is IllegalStateException -> "SERVICE_UNAVAILABLE"
+    is IllegalArgumentException -> "ARGUMENT_VALIDATION_ERROR"
+    is RemoteException -> "UNDERLYING_ERROR"
+    is InvalidRecordType -> "INVALID_RECORD_TYPE"
+    is ClientNotInitialized -> "CLIENT_NOT_INITIALIZED"
+    is InvalidTemperature -> "INVALID_TEMPERATURE"
+    is InvalidEnergy -> "INVALID_ENERGY"
+    is InvalidPower -> "INVALID_POWER"
+    is InvalidBloodGlucoseLevel -> "INVALID_BLOOD_GLUCOSE_LEVEL"
+    is InvalidBloodPressure -> "INVALID_BLOOD_PRESSURE"
+    is InvalidMass -> "INVALID_MASS"
+    is AggregationNotSupported -> "AGGREGATION_NOT_SUPPORTED"
+    else -> "UNKNOWN_ERROR"
+  }
+
+  this.reject(code, exception.message)
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt
new file mode 100644
index 0000000..774a46d
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt
@@ -0,0 +1,342 @@
+package dev.matinzd.healthconnect.utils
+
+import androidx.health.connect.client.records.*
+import androidx.health.connect.client.records.metadata.DataOrigin
+import androidx.health.connect.client.records.metadata.Metadata
+import androidx.health.connect.client.request.ReadRecordsRequest
+import androidx.health.connect.client.time.TimeRangeFilter
+import androidx.health.connect.client.units.*
+import com.facebook.react.bridge.ReadableArray
+import com.facebook.react.bridge.ReadableMap
+import com.facebook.react.bridge.WritableNativeArray
+import com.facebook.react.bridge.WritableNativeMap
+import dev.matinzd.healthconnect.records.*
+import java.time.Instant
+import kotlin.reflect.KClass
+
+fun <T : Record> convertReactRequestOptionsFromJS(
+  recordType: KClass<T>, options: ReadableMap
+): ReadRecordsRequest<T> {
+  // Move to refined version
+  // inline fun <reified T : Record> ReadRecordsRequest()
+  // link: https://android-review.googlesource.com/#/q/If58a5c2c9acea1c22b322537daa4fa513065e393
+  return ReadRecordsRequest(
+    recordType,
+    timeRangeFilter = options.getTimeRangeFilter("timeRangeFilter"),
+    dataOriginFilter = convertJsToDataOriginSet(options.getArray("dataOriginFilter")),
+    ascendingOrder = options.getSafeBoolean("ascendingOrder", true),
+    pageSize = options.getSafeInt("pageSize", 1000),
+    pageToken = if (options.hasKey("pageToken")) options.getString("pageToken") else null,
+  )
+}
+
+fun convertDataOriginsToJsArray(dataOrigin: Set<DataOrigin>): WritableNativeArray {
+  return WritableNativeArray().apply {
+    dataOrigin.forEach {
+      pushString(it.packageName)
+    }
+  }
+}
+
+fun convertJsToDataOriginSet(readableArray: ReadableArray?): Set<DataOrigin> {
+  if (readableArray == null) {
+    return emptySet()
+  }
+
+  return readableArray.toArrayList().mapNotNull { DataOrigin(it.toString()) }.toSet()
+}
+
+fun ReadableArray.toMapList(): List<ReadableMap> {`n  val list = mutableListOf<ReadableMap>()`n  for (i in 0 until size()) {`n    getMap(i)?.let { list.add(it) }`n  }`n  return list`n}
+
+fun ReadableMap.getSafeInt(key: String, default: Int): Int {
+  return if (this.hasKey(key)) this.getInt(key) else default
+}
+
+fun ReadableMap.getSafeBoolean(key: String, default: Boolean): Boolean {
+  return if (this.hasKey(key)) this.getBoolean(key) else default
+}
+
+fun ReadableMap.getSafeString(key: String, default: String): String {
+  return if (this.hasKey(key)) this.getString(key) ?: default else default
+}
+
+fun ReadableMap.getTimeRangeFilter(key: String? = null): TimeRangeFilter {
+  val timeRangeFilter = if (key != null) this.getMap(key)
+    ?: throw Exception("Time range filter should be provided") else this
+
+  val operator = timeRangeFilter.getString("operator")
+
+  val startTime =
+    if (timeRangeFilter.hasKey("startTime")) Instant.parse(timeRangeFilter.getString("startTime")) else null
+
+  val endTime =
+    if (timeRangeFilter.hasKey("endTime")) Instant.parse(timeRangeFilter.getString("endTime")) else null
+
+  when (operator) {
+    "between" -> {
+      if (startTime == null || endTime == null) {
+        throw Exception("Start time and end time should be provided")
+      }
+
+      return TimeRangeFilter.between(startTime, endTime)
+    }
+    "after" -> {
+      if (startTime == null) {
+        throw Exception("Start time should be provided")
+      }
+
+      return TimeRangeFilter.after(startTime)
+    }
+    "before" -> {
+      if (endTime == null) {
+        throw Exception("End time should be provided")
+      }
+
+      return TimeRangeFilter.before(endTime)
+    }
+    else -> {
+      if (startTime == null || endTime == null) {
+        throw Exception("Start time and end time should be provided")
+      }
+
+      return TimeRangeFilter.between(startTime, endTime)
+    }
+  }
+}
+
+fun convertMetadataToJSMap(meta: Metadata): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putString("id", meta.id)
+    putString("clientRecordId", meta.clientRecordId)
+    putDouble("clientRecordVersion", meta.clientRecordVersion.toDouble())
+    putString("dataOrigin", meta.dataOrigin.packageName)
+    putString("lastModifiedTime", meta.lastModifiedTime.toString())
+    putInt("device", meta.device?.type ?: 0)
+    putInt("recordingMethod", meta.recordingMethod)
+  }
+}
+
+val reactRecordTypeToClassMap: Map<String, KClass<out Record>> = mapOf(
+  "ActiveCaloriesBurned" to ActiveCaloriesBurnedRecord::class,
+  "BasalBodyTemperature" to BasalBodyTemperatureRecord::class,
+  "BasalMetabolicRate" to BasalMetabolicRateRecord::class,
+  "BloodGlucose" to BloodGlucoseRecord::class,
+  "BloodPressure" to BloodPressureRecord::class,
+  "BodyFat" to BodyFatRecord::class,
+  "BodyTemperature" to BodyTemperatureRecord::class,
+  "BodyWaterMass" to BodyWaterMassRecord::class,
+  "BoneMass" to BoneMassRecord::class,
+  "CervicalMucus" to CervicalMucusRecord::class,
+  "CyclingPedalingCadence" to CyclingPedalingCadenceRecord::class,
+  "Distance" to DistanceRecord::class,
+  "ElevationGained" to ElevationGainedRecord::class,
+  "ExerciseSession" to ExerciseSessionRecord::class,
+  "FloorsClimbed" to FloorsClimbedRecord::class,
+  "HeartRate" to HeartRateRecord::class,
+  "HeartRateVariabilityRmssd" to HeartRateVariabilityRmssdRecord::class,
+  "Height" to HeightRecord::class,
+  "Hydration" to HydrationRecord::class,
+  "LeanBodyMass" to LeanBodyMassRecord::class,
+  "MenstruationFlow" to MenstruationFlowRecord::class,
+  "Nutrition" to NutritionRecord::class,
+  "OvulationTest" to OvulationTestRecord::class,
+  "OxygenSaturation" to OxygenSaturationRecord::class,
+  "Power" to PowerRecord::class,
+  "RespiratoryRate" to RespiratoryRateRecord::class,
+  "RestingHeartRate" to RestingHeartRateRecord::class,
+  "SexualActivity" to SexualActivityRecord::class,
+  "SleepSession" to SleepSessionRecord::class,
+  "Speed" to SpeedRecord::class,
+  "StepsCadence" to StepsCadenceRecord::class,
+  "Steps" to StepsRecord::class,
+  "TotalCaloriesBurned" to TotalCaloriesBurnedRecord::class,
+  "Vo2Max" to Vo2MaxRecord::class,
+  "Weight" to WeightRecord::class,
+  "WheelchairPushes" to WheelchairPushesRecord::class,
+  "IntermenstrualBleeding" to IntermenstrualBleedingRecord::class,
+  "MenstruationPeriod" to MenstruationPeriodRecord::class
+)
+
+val reactRecordTypeToReactClassMap: Map<String, Class<out ReactHealthRecordImpl<*>>> = mapOf(
+  "ActiveCaloriesBurned" to ReactActiveCaloriesBurnedRecord::class.java,
+  "BasalBodyTemperature" to ReactBasalBodyTemperatureRecord::class.java,
+  "BasalMetabolicRate" to ReactBasalMetabolicRateRecord::class.java,
+  "BloodGlucose" to ReactBloodGlucoseRecord::class.java,
+  "BloodPressure" to ReactBloodPressureRecord::class.java,
+  "BodyFat" to ReactBodyFatRecord::class.java,
+  "BodyTemperature" to ReactBodyTemperatureRecord::class.java,
+  "BodyWaterMass" to ReactBodyWaterMassRecord::class.java,
+  "BoneMass" to ReactBoneMassRecord::class.java,
+  "CervicalMucus" to ReactCervicalMucusRecord::class.java,
+  "CyclingPedalingCadence" to ReactCyclingPedalingCadenceRecord::class.java,
+  "Distance" to ReactDistanceRecord::class.java,
+  "ElevationGained" to ReactElevationGainedRecord::class.java,
+  "ExerciseSession" to ReactExerciseSessionRecord::class.java,
+  "FloorsClimbed" to ReactFloorsClimbedRecord::class.java,
+  "HeartRate" to ReactHeartRateRecord::class.java,
+  "HeartRateVariabilityRmssd" to ReactHeartRateVariabilityRmssdRecord::class.java,
+  "Height" to ReactHeightRecord::class.java,
+  "Hydration" to ReactHydrationRecord::class.java,
+  "LeanBodyMass" to ReactLeanBodyMassRecord::class.java,
+  "MenstruationFlow" to ReactMenstruationFlowRecord::class.java,
+  "Nutrition" to ReactNutritionRecord::class.java,
+  "OvulationTest" to ReactOvulationTestRecord::class.java,
+  "OxygenSaturation" to ReactOxygenSaturationRecord::class.java,
+  "Power" to ReactPowerRecord::class.java,
+  "RespiratoryRate" to ReactRespiratoryRateRecord::class.java,
+  "RestingHeartRate" to ReactRestingHeartRateRecord::class.java,
+  "SexualActivity" to ReactSexualActivityRecord::class.java,
+  "SleepSession" to ReactSleepSessionRecord::class.java,
+  "Speed" to ReactSpeedRecord::class.java,
+  "StepsCadence" to ReactStepsCadenceRecord::class.java,
+  "Steps" to ReactStepsRecord::class.java,
+  "TotalCaloriesBurned" to ReactTotalCaloriesBurnedRecord::class.java,
+  "Vo2Max" to ReactVo2MaxRecord::class.java,
+  "Weight" to ReactWeightRecord::class.java,
+  "WheelchairPushes" to ReactWheelchairPushesRecord::class.java,
+  "IntermenstrualBleeding" to ReactIntermenstrualBleedingRecord::class.java,
+  "MenstruationPeriod" to ReactMenstruationPeriodRecord::class.java
+)
+
+fun massToJsMap(mass: Mass?): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putDouble("inGrams", mass?.inGrams ?: 0.0)
+    putDouble("inKilograms", mass?.inKilograms ?: 0.0)
+    putDouble("inMilligrams", mass?.inMilligrams ?: 0.0)
+    putDouble("inMicrograms", mass?.inMicrograms ?: 0.0)
+    putDouble("inOunces", mass?.inOunces ?: 0.0)
+    putDouble("inPounds", mass?.inPounds ?: 0.0)
+  }
+}
+
+fun getMassFromJsMap(massMap: ReadableMap?): Mass {
+  if (massMap == null) {
+    throw InvalidMass()
+  }
+
+  val value = massMap.getDouble("value")
+  return when (massMap.getString("unit")) {
+    "grams" -> Mass.grams(value)
+    "kilograms" -> Mass.kilograms(value)
+    "milligrams" -> Mass.milligrams(value)
+    "micrograms" -> Mass.micrograms(value)
+    "ounces" -> Mass.ounces(value)
+    "pounds" -> Mass.pounds(value)
+    else -> Mass.grams(value)
+  }
+}
+
+fun getLengthFromJsMap(length: ReadableMap?): Length {
+  if (length == null) {
+    throw InvalidLength()
+  }
+
+  val value = length.getDouble("value")
+  return when (length.getString("unit")) {
+    "meters" -> Length.meters(value)
+    "kilometers" -> Length.kilometers(value)
+    "miles" -> Length.miles(value)
+    "inches" -> Length.inches(value)
+    "feet" -> Length.feet(value)
+    else -> Length.meters(value)
+  }
+}
+
+fun lengthToJsMap(length: Length?): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putDouble("inMeters", length?.inMeters ?: 0.0)
+    putDouble("inKilometers", length?.inKilometers ?: 0.0)
+    putDouble("inMiles", length?.inMiles ?: 0.0)
+    putDouble("inInches", length?.inInches ?: 0.0)
+    putDouble("inFeet", length?.inFeet ?: 0.0)
+  }
+}
+
+fun getVolumeFromJsMap(volume: ReadableMap?): Volume {
+  if (volume == null) {
+    throw InvalidLength()
+  }
+
+  val value = volume.getDouble("value")
+  return when (volume.getString("unit")) {
+    "fluidOuncesUs" -> Volume.fluidOuncesUs(value)
+    "liters" -> Volume.liters(value)
+    "milliliters" -> Volume.milliliters(value)
+    else -> Volume.liters(value)
+  }
+}
+
+fun volumeToJsMap(volume: Volume?): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putDouble("inLiters", volume?.inLiters ?: 0.0)
+    putDouble("inFluidOuncesUs", volume?.inFluidOuncesUs ?: 0.0)
+    putDouble("inMilliliters", volume?.inMilliliters ?: 0.0)
+  }
+}
+
+fun getEnergyFromJsMap(energyMap: ReadableMap?): Energy {
+  if (energyMap == null) {
+    throw InvalidEnergy()
+  }
+
+  val value = energyMap.getDouble("value")
+  return when (energyMap.getString("unit")) {
+    "kilojoules" -> Energy.kilocalories(value)
+    "kilocalories" -> Energy.kilojoules(value)
+    "joules" -> Energy.joules(value)
+    "calories" -> Energy.calories(value)
+    else -> Energy.calories(value)
+  }
+}
+
+fun energyToJsMap(energy: Energy?): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putDouble("inCalories", energy?.inCalories ?: 0.0)
+    putDouble("inJoules", energy?.inJoules ?: 0.0)
+    putDouble("inKilocalories", energy?.inKilocalories ?: 0.0)
+    putDouble("inKilojoules", energy?.inKilojoules ?: 0.0)
+  }
+}
+
+fun getVelocityFromJsMap(velocityMap: ReadableMap?): Velocity {
+  if (velocityMap == null) {
+    throw InvalidVelocity()
+  }
+
+  val value = velocityMap.getDouble("value")
+  return when (velocityMap.getString("unit")) {
+    "kilometersPerHour" -> Velocity.kilometersPerHour(value)
+    "metersPerSecond" -> Velocity.metersPerSecond(value)
+    "milesPerHour" -> Velocity.milesPerHour(value)
+    else -> Velocity.kilometersPerHour(value)
+  }
+}
+
+fun velocityToJsMap(velocity: Velocity?): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putDouble("inKilometersPerHour", velocity?.inKilometersPerHour ?: 0.0)
+    putDouble("inMetersPerSecond", velocity?.inMetersPerSecond ?: 0.0)
+    putDouble("inMilesPerHour", velocity?.inMilesPerHour ?: 0.0)
+  }
+}
+
+fun getPowerFromJsMap(powerMap: ReadableMap?): Power {
+  if (powerMap == null) {
+    throw InvalidVelocity()
+  }
+
+  val value = powerMap.getDouble("value")
+  return when (powerMap.getString("unit")) {
+    "watts" -> Power.watts(value)
+    "kilocaloriesPerDay" -> Power.kilocaloriesPerDay(value)
+    else -> Power.kilocaloriesPerDay(value)
+  }
+}
+
+fun powerToJsMap(power: Power?): WritableNativeMap {
+  return WritableNativeMap().apply {
+    putDouble("inWatts", power?.inWatts ?: 0.0)
+    putDouble("inKilocaloriesPerDay", power?.inKilocaloriesPerDay ?: 0.0)
+  }
+}
+
diff --git a/node_modules/react-native-health-connect/android/bin/src/newarch/HealthConnectSpec.kt b/node_modules/react-native-health-connect/android/bin/src/newarch/HealthConnectSpec.kt
new file mode 100644
index 0000000..827c06f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/newarch/HealthConnectSpec.kt
@@ -0,0 +1,7 @@
+package dev.matinzd.healthconnect
+
+import com.facebook.react.bridge.ReactApplicationContext
+
+abstract class HealthConnectSpec internal constructor(context: ReactApplicationContext) :
+  NativeHealthConnectSpec(context) {
+}
diff --git a/node_modules/react-native-health-connect/android/bin/src/oldarch/HealthConnectSpec.kt b/node_modules/react-native-health-connect/android/bin/src/oldarch/HealthConnectSpec.kt
new file mode 100644
index 0000000..72eb7c5
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/bin/src/oldarch/HealthConnectSpec.kt
@@ -0,0 +1,46 @@
+package dev.matinzd.healthconnect
+
+import com.facebook.react.bridge.*
+
+abstract class HealthConnectSpec internal constructor(context: ReactApplicationContext) :
+  ReactContextBaseJavaModule(context) {
+
+  @ReactMethod
+  abstract fun getSdkStatus(providerPackageName: String, promise: Promise)
+
+  @ReactMethod
+  abstract fun initialize(providerPackageName: String, promise: Promise);
+
+  @ReactMethod
+  abstract fun openHealthConnectSettings();
+
+  @ReactMethod
+  abstract fun openHealthConnectDataManagement(providerPackageName: String?);
+
+  @ReactMethod
+  abstract fun requestPermission(permissions: ReadableArray, providerPackageName: String, promise: Promise);
+
+  @ReactMethod
+  abstract fun getGrantedPermissions(promise: Promise);
+
+  @ReactMethod
+  abstract fun revokeAllPermissions(promise: Promise);
+
+  @ReactMethod
+  abstract fun insertRecords(records: ReadableArray, promise: Promise);
+
+  @ReactMethod
+  abstract fun readRecords(recordType: String, options: ReadableMap, promise: Promise);
+
+  @ReactMethod
+  abstract fun readRecord(recordType: String, recordId: String, promise: Promise);
+
+  @ReactMethod
+  abstract fun aggregateRecord(record: ReadableMap, promise: Promise);
+
+  @ReactMethod
+  abstract fun deleteRecordsByUuids(recordType: String, recordIdsList: ReadableArray, clientRecordIdsList: ReadableArray, promise: Promise);
+
+  @ReactMethod
+  abstract fun deleteRecordsByTimeRange(recordType: String, timeRangeFilter: ReadableMap, promise: Promise);
+}
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/buildConfig/release/dev/matinzd/healthconnect/BuildConfig.java b/node_modules/react-native-health-connect/android/build/generated/source/buildConfig/release/dev/matinzd/healthconnect/BuildConfig.java
new file mode 100644
index 0000000..cbb1bc8
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/buildConfig/release/dev/matinzd/healthconnect/BuildConfig.java
@@ -0,0 +1,12 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package dev.matinzd.healthconnect;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = false;
+  public static final String LIBRARY_PACKAGE_NAME = "dev.matinzd.healthconnect";
+  public static final String BUILD_TYPE = "release";
+  // Field from default config.
+  public static final boolean IS_NEW_ARCHITECTURE_ENABLED = true;
+}
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/java/dev/matinzd/healthconnect/NativeHealthConnectSpec.java b/node_modules/react-native-health-connect/android/build/generated/source/codegen/java/dev/matinzd/healthconnect/NativeHealthConnectSpec.java
new file mode 100644
index 0000000..c68657a
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/java/dev/matinzd/healthconnect/NativeHealthConnectSpec.java
@@ -0,0 +1,89 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package dev.matinzd.healthconnect;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeHealthConnectSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "HealthConnect";
+
+  public NativeHealthConnectSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getSdkStatus(String providerPackageName, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void initialize(String providerPackageName, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void openHealthConnectSettings();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void openHealthConnectDataManagement(@Nullable String providerPackageName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void requestPermission(ReadableArray permissions, String providerPackageName, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getGrantedPermissions(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void revokeAllPermissions(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void insertRecords(ReadableArray records, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void readRecords(String recordType, ReadableMap options, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void readRecord(String recordType, String recordId, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void aggregateRecord(ReadableMap record, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void deleteRecordsByUuids(String recordType, ReadableArray recordIdsList, ReadableArray clientRecordIdsList, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void deleteRecordsByTimeRange(String recordType, ReadableMap timeRangeFilter, Promise promise);
+}
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/CMakeLists.txt b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/CMakeLists.txt
new file mode 100644
index 0000000..5701996
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/CMakeLists.txt
@@ -0,0 +1,28 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+cmake_minimum_required(VERSION 3.13)
+set(CMAKE_VERBOSE_MAKEFILE on)
+
+file(GLOB react_codegen_SRCS CONFIGURE_DEPENDS *.cpp react/renderer/components/RNHealthConnectSpec/*.cpp)
+
+add_library(
+  react_codegen_RNHealthConnectSpec
+  OBJECT
+  ${react_codegen_SRCS}
+)
+
+target_include_directories(react_codegen_RNHealthConnectSpec PUBLIC . react/renderer/components/RNHealthConnectSpec)
+
+target_link_libraries(
+  react_codegen_RNHealthConnectSpec
+  fbjni
+  jsi
+  # We need to link different libraries based on whether we are building rncore or not, that's necessary
+  # because we want to break a circular dependency between react_codegen_rncore and reactnative
+  reactnative
+)
+
+target_compile_reactnative_options(react_codegen_RNHealthConnectSpec PRIVATE)
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/RNHealthConnectSpec-generated.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/RNHealthConnectSpec-generated.cpp
new file mode 100644
index 0000000..5551d5f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/RNHealthConnectSpec-generated.cpp
@@ -0,0 +1,104 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniCpp.js
+ */
+
+#include "RNHealthConnectSpec.h"
+
+namespace facebook::react {
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_getSdkStatus(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getSdkStatus", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_initialize(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "initialize", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectSettings(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "openHealthConnectSettings", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectDataManagement(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "openHealthConnectDataManagement", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_requestPermission(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "requestPermission", "(Lcom/facebook/react/bridge/ReadableArray;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_getGrantedPermissions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getGrantedPermissions", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_revokeAllPermissions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "revokeAllPermissions", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_insertRecords(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "insertRecords", "(Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_readRecords(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "readRecords", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_readRecord(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "readRecord", "(Ljava/lang/String;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_aggregateRecord(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "aggregateRecord", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByUuids(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "deleteRecordsByUuids", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByTimeRange(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "deleteRecordsByTimeRange", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeHealthConnectSpecJSI::NativeHealthConnectSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getSdkStatus"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_getSdkStatus};
+  methodMap_["initialize"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_initialize};
+  methodMap_["openHealthConnectSettings"] = MethodMetadata {0, __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectSettings};
+  methodMap_["openHealthConnectDataManagement"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_openHealthConnectDataManagement};
+  methodMap_["requestPermission"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_requestPermission};
+  methodMap_["getGrantedPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectSpecJSI_getGrantedPermissions};
+  methodMap_["revokeAllPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectSpecJSI_revokeAllPermissions};
+  methodMap_["insertRecords"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_insertRecords};
+  methodMap_["readRecords"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_readRecords};
+  methodMap_["readRecord"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_readRecord};
+  methodMap_["aggregateRecord"] = MethodMetadata {1, __hostFunction_NativeHealthConnectSpecJSI_aggregateRecord};
+  methodMap_["deleteRecordsByUuids"] = MethodMetadata {3, __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByUuids};
+  methodMap_["deleteRecordsByTimeRange"] = MethodMetadata {2, __hostFunction_NativeHealthConnectSpecJSI_deleteRecordsByTimeRange};
+}
+
+std::shared_ptr<TurboModule> RNHealthConnectSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params) {
+  if (moduleName == "HealthConnect") {
+    return std::make_shared<NativeHealthConnectSpecJSI>(params);
+  }
+  return nullptr;
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/RNHealthConnectSpec.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/RNHealthConnectSpec.h
new file mode 100644
index 0000000..d5227b1
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/RNHealthConnectSpec.h
@@ -0,0 +1,31 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/JavaTurboModule.h>
+#include <ReactCommon/TurboModule.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+/**
+ * JNI C++ class for module 'NativeHealthConnect'
+ */
+class JSI_EXPORT NativeHealthConnectSpecJSI : public JavaTurboModule {
+public:
+  NativeHealthConnectSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+
+JSI_EXPORT
+std::shared_ptr<TurboModule> RNHealthConnectSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.cpp
new file mode 100644
index 0000000..29db675
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.cpp
@@ -0,0 +1,22 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+void RNHealthConnectSpec_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry) {
+
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h
new file mode 100644
index 0000000..87d5756
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ComponentDescriptors.h
@@ -0,0 +1,24 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/RNHealthConnectSpec/ShadowNodes.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+
+
+void RNHealthConnectSpec_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.cpp
new file mode 100644
index 0000000..f7c4764
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/EventEmitters.h>
+
+
+namespace facebook::react {
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.h
new file mode 100644
index 0000000..2845a63
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/EventEmitters.h
@@ -0,0 +1,17 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewEventEmitter.h>
+
+
+namespace facebook::react {
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.cpp
new file mode 100644
index 0000000..322a5d3
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.cpp
@@ -0,0 +1,19 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/Props.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/core/propsConversions.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.h
new file mode 100644
index 0000000..870864b
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/Props.h
@@ -0,0 +1,18 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsH.js
+ */
+#pragma once
+
+
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI-generated.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI-generated.cpp
new file mode 100644
index 0000000..55a5d58
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI-generated.cpp
@@ -0,0 +1,116 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleCpp.js
+ */
+
+#include "RNHealthConnectSpecJSI.h"
+
+namespace facebook::react {
+
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_getSdkStatus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->getSdkStatus(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_initialize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->initialize(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->openHealthConnectSettings(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectDataManagement(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->openHealthConnectDataManagement(
+    rt,
+    count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt))
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_requestPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->requestPermission(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_getGrantedPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->getGrantedPermissions(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_revokeAllPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->revokeAllPermissions(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_insertRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->insertRecords(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_readRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->readRecords(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_readRecord(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->readRecord(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_aggregateRecord(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->aggregateRecord(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByUuids(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->deleteRecordsByUuids(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asArray(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByTimeRange(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHealthConnectCxxSpecJSI *>(&turboModule)->deleteRecordsByTimeRange(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+
+NativeHealthConnectCxxSpecJSI::NativeHealthConnectCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("HealthConnect", jsInvoker) {
+  methodMap_["getSdkStatus"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_getSdkStatus};
+  methodMap_["initialize"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_initialize};
+  methodMap_["openHealthConnectSettings"] = MethodMetadata {0, __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectSettings};
+  methodMap_["openHealthConnectDataManagement"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_openHealthConnectDataManagement};
+  methodMap_["requestPermission"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_requestPermission};
+  methodMap_["getGrantedPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectCxxSpecJSI_getGrantedPermissions};
+  methodMap_["revokeAllPermissions"] = MethodMetadata {0, __hostFunction_NativeHealthConnectCxxSpecJSI_revokeAllPermissions};
+  methodMap_["insertRecords"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_insertRecords};
+  methodMap_["readRecords"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_readRecords};
+  methodMap_["readRecord"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_readRecord};
+  methodMap_["aggregateRecord"] = MethodMetadata {1, __hostFunction_NativeHealthConnectCxxSpecJSI_aggregateRecord};
+  methodMap_["deleteRecordsByUuids"] = MethodMetadata {3, __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByUuids};
+  methodMap_["deleteRecordsByTimeRange"] = MethodMetadata {2, __hostFunction_NativeHealthConnectCxxSpecJSI_deleteRecordsByTimeRange};
+}
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI.h
new file mode 100644
index 0000000..98666c2
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/RNHealthConnectSpecJSI.h
@@ -0,0 +1,262 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/TurboModule.h>
+#include <react/bridging/Bridging.h>
+
+namespace facebook::react {
+
+
+  
+#pragma mark - NativeHealthConnectReadRecordsOptions
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
+struct NativeHealthConnectReadRecordsOptions {
+  P0 startTime;
+  P1 endTime;
+  P2 dataOriginFilter;
+  P3 ascendingOrder;
+  P4 pageSize;
+  P5 pageToken;
+  bool operator==(const NativeHealthConnectReadRecordsOptions &other) const {
+    return startTime == other.startTime && endTime == other.endTime && dataOriginFilter == other.dataOriginFilter && ascendingOrder == other.ascendingOrder && pageSize == other.pageSize && pageToken == other.pageToken;
+  }
+};
+
+template <typename T>
+struct NativeHealthConnectReadRecordsOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.startTime)>(rt, value.getProperty(rt, "startTime"), jsInvoker),
+      bridging::fromJs<decltype(types.endTime)>(rt, value.getProperty(rt, "endTime"), jsInvoker),
+      bridging::fromJs<decltype(types.dataOriginFilter)>(rt, value.getProperty(rt, "dataOriginFilter"), jsInvoker),
+      bridging::fromJs<decltype(types.ascendingOrder)>(rt, value.getProperty(rt, "ascendingOrder"), jsInvoker),
+      bridging::fromJs<decltype(types.pageSize)>(rt, value.getProperty(rt, "pageSize"), jsInvoker),
+      bridging::fromJs<decltype(types.pageToken)>(rt, value.getProperty(rt, "pageToken"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String startTimeToJs(jsi::Runtime &rt, decltype(types.startTime) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String endTimeToJs(jsi::Runtime &rt, decltype(types.endTime) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array dataOriginFilterToJs(jsi::Runtime &rt, decltype(types.dataOriginFilter) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool ascendingOrderToJs(jsi::Runtime &rt, decltype(types.ascendingOrder) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double pageSizeToJs(jsi::Runtime &rt, decltype(types.pageSize) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String pageTokenToJs(jsi::Runtime &rt, decltype(types.pageToken) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
+    result.setProperty(rt, "endTime", bridging::toJs(rt, value.endTime, jsInvoker));
+    if (value.dataOriginFilter) {
+      result.setProperty(rt, "dataOriginFilter", bridging::toJs(rt, value.dataOriginFilter.value(), jsInvoker));
+    }
+    if (value.ascendingOrder) {
+      result.setProperty(rt, "ascendingOrder", bridging::toJs(rt, value.ascendingOrder.value(), jsInvoker));
+    }
+    if (value.pageSize) {
+      result.setProperty(rt, "pageSize", bridging::toJs(rt, value.pageSize.value(), jsInvoker));
+    }
+    if (value.pageToken) {
+      result.setProperty(rt, "pageToken", bridging::toJs(rt, value.pageToken.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeHealthConnectCxxSpecJSI : public TurboModule {
+protected:
+  NativeHealthConnectCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getSdkStatus(jsi::Runtime &rt, jsi::String providerPackageName) = 0;
+  virtual jsi::Value initialize(jsi::Runtime &rt, jsi::String providerPackageName) = 0;
+  virtual void openHealthConnectSettings(jsi::Runtime &rt) = 0;
+  virtual void openHealthConnectDataManagement(jsi::Runtime &rt, std::optional<jsi::String> providerPackageName) = 0;
+  virtual jsi::Value requestPermission(jsi::Runtime &rt, jsi::Array permissions, jsi::String providerPackageName) = 0;
+  virtual jsi::Value getGrantedPermissions(jsi::Runtime &rt) = 0;
+  virtual jsi::Value revokeAllPermissions(jsi::Runtime &rt) = 0;
+  virtual jsi::Value insertRecords(jsi::Runtime &rt, jsi::Array records) = 0;
+  virtual jsi::Value readRecords(jsi::Runtime &rt, jsi::String recordType, jsi::Object options) = 0;
+  virtual jsi::Value readRecord(jsi::Runtime &rt, jsi::String recordType, jsi::String recordId) = 0;
+  virtual jsi::Value aggregateRecord(jsi::Runtime &rt, jsi::Object record) = 0;
+  virtual jsi::Value deleteRecordsByUuids(jsi::Runtime &rt, jsi::String recordType, jsi::Array recordIdsList, jsi::Array clientRecordIdsList) = 0;
+  virtual jsi::Value deleteRecordsByTimeRange(jsi::Runtime &rt, jsi::String recordType, jsi::Object timeRangeFilter) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeHealthConnectCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "HealthConnect";
+
+protected:
+  NativeHealthConnectCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeHealthConnectCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeHealthConnectCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeHealthConnectCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getSdkStatus(jsi::Runtime &rt, jsi::String providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSdkStatus) == 2,
+          "Expected getSdkStatus(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getSdkStatus, jsInvoker_, instance_, std::move(providerPackageName));
+    }
+    jsi::Value initialize(jsi::Runtime &rt, jsi::String providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::initialize) == 2,
+          "Expected initialize(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::initialize, jsInvoker_, instance_, std::move(providerPackageName));
+    }
+    void openHealthConnectSettings(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::openHealthConnectSettings) == 1,
+          "Expected openHealthConnectSettings(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::openHealthConnectSettings, jsInvoker_, instance_);
+    }
+    void openHealthConnectDataManagement(jsi::Runtime &rt, std::optional<jsi::String> providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::openHealthConnectDataManagement) == 2,
+          "Expected openHealthConnectDataManagement(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::openHealthConnectDataManagement, jsInvoker_, instance_, std::move(providerPackageName));
+    }
+    jsi::Value requestPermission(jsi::Runtime &rt, jsi::Array permissions, jsi::String providerPackageName) override {
+      static_assert(
+          bridging::getParameterCount(&T::requestPermission) == 3,
+          "Expected requestPermission(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::requestPermission, jsInvoker_, instance_, std::move(permissions), std::move(providerPackageName));
+    }
+    jsi::Value getGrantedPermissions(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getGrantedPermissions) == 1,
+          "Expected getGrantedPermissions(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getGrantedPermissions, jsInvoker_, instance_);
+    }
+    jsi::Value revokeAllPermissions(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::revokeAllPermissions) == 1,
+          "Expected revokeAllPermissions(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::revokeAllPermissions, jsInvoker_, instance_);
+    }
+    jsi::Value insertRecords(jsi::Runtime &rt, jsi::Array records) override {
+      static_assert(
+          bridging::getParameterCount(&T::insertRecords) == 2,
+          "Expected insertRecords(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::insertRecords, jsInvoker_, instance_, std::move(records));
+    }
+    jsi::Value readRecords(jsi::Runtime &rt, jsi::String recordType, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::readRecords) == 3,
+          "Expected readRecords(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::readRecords, jsInvoker_, instance_, std::move(recordType), std::move(options));
+    }
+    jsi::Value readRecord(jsi::Runtime &rt, jsi::String recordType, jsi::String recordId) override {
+      static_assert(
+          bridging::getParameterCount(&T::readRecord) == 3,
+          "Expected readRecord(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::readRecord, jsInvoker_, instance_, std::move(recordType), std::move(recordId));
+    }
+    jsi::Value aggregateRecord(jsi::Runtime &rt, jsi::Object record) override {
+      static_assert(
+          bridging::getParameterCount(&T::aggregateRecord) == 2,
+          "Expected aggregateRecord(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::aggregateRecord, jsInvoker_, instance_, std::move(record));
+    }
+    jsi::Value deleteRecordsByUuids(jsi::Runtime &rt, jsi::String recordType, jsi::Array recordIdsList, jsi::Array clientRecordIdsList) override {
+      static_assert(
+          bridging::getParameterCount(&T::deleteRecordsByUuids) == 4,
+          "Expected deleteRecordsByUuids(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::deleteRecordsByUuids, jsInvoker_, instance_, std::move(recordType), std::move(recordIdsList), std::move(clientRecordIdsList));
+    }
+    jsi::Value deleteRecordsByTimeRange(jsi::Runtime &rt, jsi::String recordType, jsi::Object timeRangeFilter) override {
+      static_assert(
+          bridging::getParameterCount(&T::deleteRecordsByTimeRange) == 3,
+          "Expected deleteRecordsByTimeRange(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::deleteRecordsByTimeRange, jsInvoker_, instance_, std::move(recordType), std::move(timeRangeFilter));
+    }
+
+  private:
+    friend class NativeHealthConnectCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.cpp
new file mode 100644
index 0000000..afa35d4
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.cpp
@@ -0,0 +1,17 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeCpp.js
+ */
+
+#include <react/renderer/components/RNHealthConnectSpec/ShadowNodes.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.h
new file mode 100644
index 0000000..84de0bc
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/ShadowNodes.h
@@ -0,0 +1,23 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/RNHealthConnectSpec/EventEmitters.h>
+#include <react/renderer/components/RNHealthConnectSpec/Props.h>
+#include <react/renderer/components/RNHealthConnectSpec/States.h>
+#include <react/renderer/components/view/ConcreteViewShadowNode.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.cpp b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.cpp
new file mode 100644
index 0000000..248aefe
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateCpp.js
+ */
+#include <react/renderer/components/RNHealthConnectSpec/States.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.h b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.h
new file mode 100644
index 0000000..2e55bce
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/jni/react/renderer/components/RNHealthConnectSpec/States.h
@@ -0,0 +1,20 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateH.js
+ */
+#pragma once
+
+#include <react/renderer/core/StateData.h>
+#ifdef RN_SERIALIZABLE_STATE
+#include <folly/dynamic.h>
+#endif
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/generated/source/codegen/schema.json b/node_modules/react-native-health-connect/android/build/generated/source/codegen/schema.json
new file mode 100644
index 0000000..f192e5e
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/generated/source/codegen/schema.json
@@ -0,0 +1 @@
+{"libraryName":"","modules":{"NativeHealthConnect":{"type":"NativeModule","aliasMap":{"ReadRecordsOptions":{"type":"ObjectTypeAnnotation","properties":[{"name":"startTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"endTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"dataOriginFilter","optional":true,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}},{"name":"ascendingOrder","optional":true,"typeAnnotation":{"type":"BooleanTypeAnnotation"}},{"name":"pageSize","optional":true,"typeAnnotation":{"type":"NumberTypeAnnotation"}},{"name":"pageToken","optional":true,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},"enumMap":{},"spec":{"eventEmitters":[],"methods":[{"name":"getSdkStatus","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"NumberTypeAnnotation"}},"params":[{"name":"providerPackageName","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"initialize","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"BooleanTypeAnnotation"}},"params":[{"name":"providerPackageName","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"openHealthConnectSettings","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[]}},{"name":"openHealthConnectDataManagement","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"VoidTypeAnnotation"},"params":[{"name":"providerPackageName","optional":true,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"requestPermission","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},"params":[{"name":"permissions","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},{"name":"providerPackageName","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"getGrantedPermissions","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}},"params":[]}},{"name":"revokeAllPermissions","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[]}},{"name":"insertRecords","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}},"params":[{"name":"records","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"AnyTypeAnnotation"}}}]}},{"name":"readRecords","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ArrayTypeAnnotation","elementType":{"type":"ObjectTypeAnnotation","properties":[]}}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"options","optional":false,"typeAnnotation":{"type":"TypeAliasTypeAnnotation","name":"ReadRecordsOptions"}}]}},{"name":"readRecord","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ObjectTypeAnnotation","properties":[]}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"recordId","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}},{"name":"aggregateRecord","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"ObjectTypeAnnotation","properties":[]}},"params":[{"name":"record","optional":false,"typeAnnotation":{"type":"ObjectTypeAnnotation","properties":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"startTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"endTime","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}}]}}]}},{"name":"deleteRecordsByUuids","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"recordIdsList","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}},{"name":"clientRecordIdsList","optional":false,"typeAnnotation":{"type":"ArrayTypeAnnotation","elementType":{"type":"StringTypeAnnotation"}}}]}},{"name":"deleteRecordsByTimeRange","optional":false,"typeAnnotation":{"type":"FunctionTypeAnnotation","returnTypeAnnotation":{"type":"PromiseTypeAnnotation","elementType":{"type":"VoidTypeAnnotation"}},"params":[{"name":"recordType","optional":false,"typeAnnotation":{"type":"StringTypeAnnotation"}},{"name":"timeRangeFilter","optional":false,"typeAnnotation":{"type":"GenericObjectTypeAnnotation"}}]}}]},"moduleName":"HealthConnect"}}}
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/annotation_processor_list/release/javaPreCompileRelease/annotationProcessors.json b/node_modules/react-native-health-connect/android/build/intermediates/annotation_processor_list/release/javaPreCompileRelease/annotationProcessors.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/annotation_processor_list/release/javaPreCompileRelease/annotationProcessors.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/compile_r_class_jar/release/generateReleaseRFile/R.jar b/node_modules/react-native-health-connect/android/build/intermediates/compile_r_class_jar/release/generateReleaseRFile/R.jar
new file mode 100644
index 0000000..73c5c9c
Binary files /dev/null and b/node_modules/react-native-health-connect/android/build/intermediates/compile_r_class_jar/release/generateReleaseRFile/R.jar differ
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/compile_symbol_list/release/generateReleaseRFile/R.txt b/node_modules/react-native-health-connect/android/build/intermediates/compile_symbol_list/release/generateReleaseRFile/R.txt
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/incremental/mergeReleaseJniLibFolders/merger.xml b/node_modules/react-native-health-connect/android/build/intermediates/incremental/mergeReleaseJniLibFolders/merger.xml
new file mode 100644
index 0000000..b8f71f0
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/incremental/mergeReleaseJniLibFolders/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\jniLibs"/></dataSet><dataSet config="release" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\release\jniLibs"/></dataSet></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/incremental/release/packageReleaseResources/compile-file-map.properties b/node_modules/react-native-health-connect/android/build/intermediates/incremental/release/packageReleaseResources/compile-file-map.properties
new file mode 100644
index 0000000..87c989f
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/incremental/release/packageReleaseResources/compile-file-map.properties
@@ -0,0 +1 @@
+#Sun Jan 04 09:28:04 IST 2026
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/incremental/release/packageReleaseResources/merger.xml b/node_modules/react-native-health-connect/android/build/intermediates/incremental/release/packageReleaseResources/merger.xml
new file mode 100644
index 0000000..dd7f406
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/incremental/release/packageReleaseResources/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main" generated-set="main$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="release$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\release\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="release" generated-set="release$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\release\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\build\generated\res\resValues\release"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated" generated-set="generated$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\build\generated\res\resValues\release"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/local_only_symbol_list/release/parseReleaseLocalResources/R-def.txt b/node_modules/react-native-health-connect/android/build/intermediates/local_only_symbol_list/release/parseReleaseLocalResources/R-def.txt
new file mode 100644
index 0000000..78ac5b8
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/local_only_symbol_list/release/parseReleaseLocalResources/R-def.txt
@@ -0,0 +1,2 @@
+R_DEF: Internal format may change without notice
+local
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/nested_resources_validation_report/release/generateReleaseResources/nestedResourcesValidationReport.txt b/node_modules/react-native-health-connect/android/build/intermediates/nested_resources_validation_report/release/generateReleaseResources/nestedResourcesValidationReport.txt
new file mode 100644
index 0000000..08f4ebe
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/nested_resources_validation_report/release/generateReleaseResources/nestedResourcesValidationReport.txt
@@ -0,0 +1 @@
+0 Warning/Error
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/intermediates/symbol_list_with_package_name/release/generateReleaseRFile/package-aware-r.txt b/node_modules/react-native-health-connect/android/build/intermediates/symbol_list_with_package_name/release/generateReleaseRFile/package-aware-r.txt
new file mode 100644
index 0000000..1601790
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/intermediates/symbol_list_with_package_name/release/generateReleaseRFile/package-aware-r.txt
@@ -0,0 +1 @@
+dev.matinzd.healthconnect
diff --git a/node_modules/react-native-health-connect/android/build/kotlin/compileReleaseKotlin/cacheable/dirty-sources.txt b/node_modules/react-native-health-connect/android/build/kotlin/compileReleaseKotlin/cacheable/dirty-sources.txt
new file mode 100644
index 0000000..065de3e
--- /dev/null
+++ b/node_modules/react-native-health-connect/android/build/kotlin/compileReleaseKotlin/cacheable/dirty-sources.txt
@@ -0,0 +1,47 @@
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactCervicalMucusRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactRespiratoryRateRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactNutritionRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactRestingHeartRateRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactOxygenSaturationRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactExerciseSessionRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactHealthRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\utils\ExceptionsUtils.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactHealthRecordImpl.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\permissions\HCPermissionManager.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactHeightRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactIntermenstrualBleedingRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactPowerRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactHeartRateVariabilityRmssdRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactHydrationRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactCyclingPedalingCadenceRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactWheelchairPushesRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactDistanceRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBodyFatRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactMenstruationFlowRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactStepsRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\utils\HealthConnectUtils.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBasalMetabolicRateRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBloodGlucoseRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBloodPressureRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBodyWaterMassRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactTotalCaloriesBurnedRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactOvulationTestRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactActiveCaloriesBurnedRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactWeightRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactVo2MaxRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\newarch\HealthConnectSpec.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\HealthConnectManager.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactStepsCadenceRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\HealthConnectModule.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBoneMassRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactElevationGainedRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactSleepSessionRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBasalBodyTemperatureRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactLeanBodyMassRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactMenstruationPeriodRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactBodyTemperatureRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactFloorsClimbedRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactHeartRateRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactSexualActivityRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\records\ReactSpeedRecord.kt
+C:\Platemate\PlateMate-Prod\Frontend\node_modules\react-native-health-connect\android\src\main\java\dev\matinzd\healthconnect\HealthConnectPackage.kt
\ No newline at end of file
diff --git a/node_modules/react-native-health-connect/android/build/kotlin/compileReleaseKotlin/local-state/build-history.bin b/node_modules/react-native-health-connect/android/build/kotlin/compileReleaseKotlin/local-state/build-history.bin
new file mode 100644
index 0000000..2a32a8c
Binary files /dev/null and b/node_modules/react-native-health-connect/android/build/kotlin/compileReleaseKotlin/local-state/build-history.bin differ
diff --git a/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt b/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt
index 6bc3b23..4a3703b 100644
--- a/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt
+++ b/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/HealthConnectManager.kt
@@ -35,15 +35,13 @@ class HealthConnectManager(private val applicationContext: ReactApplicationConte
     block()
   }
 
-  override fun onActivityResult(
-    activity: Activity?, requestCode: Int, resultCode: Int, intent: Intent?
-  ) {
+  override fun onActivityResult(activity: Activity, requestCode: Int, resultCode: Int, data: Intent?) {
     if (requestCode == REQUEST_CODE) {
-      HCPermissionManager.parseOnActivityResult(resultCode, intent, pendingPromise)
+      HCPermissionManager.parseOnActivityResult(resultCode, data, pendingPromise)
     }
   }
 
-  override fun onNewIntent(intent: Intent?) {}
+  override fun onNewIntent(intent: Intent) {}
 
   fun openHealthConnectSettings() {
     val intent = Intent(HealthConnectClient.ACTION_HEALTH_CONNECT_SETTINGS)
@@ -215,3 +213,5 @@ class HealthConnectManager(private val applicationContext: ReactApplicationConte
   }
 }
 
+
+
diff --git a/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt b/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt
index f4e421e..f0dfe2f 100644
--- a/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt
+++ b/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/records/ReactHealthRecord.kt
@@ -37,7 +37,7 @@ class ReactHealthRecord {
     }
 
     fun parseWriteRecords(reactRecords: ReadableArray): List<Record> {
-      val recordType = reactRecords.getMap(0).getString("recordType")
+      val recordType = reactRecords.getMap(0)?.getString("recordType")
 
       val recordClass = createReactHealthRecordInstance<Record>(recordType)
 
@@ -87,3 +87,4 @@ class ReactHealthRecord {
     }
   }
 }
+
diff --git a/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt b/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt
index 6a3219e..e554a3a 100644
--- a/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt
+++ b/node_modules/react-native-health-connect/android/src/main/java/dev/matinzd/healthconnect/utils/HealthConnectUtils.kt
@@ -49,7 +49,7 @@ fun convertJsToDataOriginSet(readableArray: ReadableArray?): Set<DataOrigin> {
 fun ReadableArray.toMapList(): List<ReadableMap> {
   val list = mutableListOf<ReadableMap>()
   for (i in 0 until size()) {
-    list.add(getMap(i))
+    getMap(i)?.let { list.add(it) }
   }
   return list
 }
@@ -345,3 +345,4 @@ fun powerToJsMap(power: Power?): WritableNativeMap {
     putDouble("inKilocaloriesPerDay", power?.inKilocaloriesPerDay ?: 0.0)
   }
 }
+
